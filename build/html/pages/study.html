

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MEISHAV &mdash; test1  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="test1" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            test1
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">MEISHAV</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#start">1. START</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#project">1.1 Project</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memory-map">Memory Map</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#background">1.2 Background</a></li>
<li class="toctree-l3"><a class="reference internal" href="#goal">1.3 Goal</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hardware">2. Hardware</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gpio">2.1 GPIO</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gpio-technical-specification">2.1.1 GPIO Technical Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#theory-of-operation">2.1.2 Theory of Operation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#uart">2.2 UART</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#uart-technical-specification">2.2.1 UART Technical Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">2.2.2 Theory of Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-verification">2.2.3 Design Verification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testplan">2.2.3.1 Testplan</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-interfaces">2.2.4 Hardware Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#registers">2.2.5 Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#checklist">2.2.6 Checklist</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#spi">2.3 SPI</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spi-technical-specification">2.3.1 SPI Technical Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">2.3.2 Design Verification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">2.3.2.1 Testplan</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-interface">2.3.3 Hardware Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">2.3.4 Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">2.3.5  Checklist</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#jtag">2.4 JTAG</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#jtag-technical-specification">2.4.1 JTAG Technical Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">2.4.2 Theory of Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#jtag-design-verification">2.4.3 JTAG Design Verification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">2.4.4 Hardware Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id32">2.4.5 Registers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">2.4.6 Checklist</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#qspi">2.5 QSPI</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qspi-technical-specification">2.5.1 QSPI Technical Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id36">2.5.2 Theory of Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qspi-design-verification">2.5.3 QSPI Design Verification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id37">2.5.4 Hardware Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id38">2.5.5 Registers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sram">2.6 SRAM</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sram-controller-technical-specification">2.6.1 SRAM Controller Technical Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id42">2.6.2 Theory of Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id43">2.6.3 Design Verification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id44">2.6.4 Hardware Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parameters">2.6.4.1 Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#external-signal-interfaces">2.6.4.2 External Signal Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#internal-signal-interfaces">2.6.4.3 Internal Signal Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alert-signals">2.6.4.4 Alert Signals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#safety-measures">2.6.4.5 Safety Measures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#register">2.6.5 Register</a></li>
<li class="toctree-l4"><a class="reference internal" href="#external-interface-function">2.6.6 External Interface Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id45">2.6.7 Checklist</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#prototype-verificaton-on-fpga">3. Prototype Verificaton On FPGA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fpga-development">3.1 FPGA Development</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fpga-version">3.1.1 FPGA Version</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chiplink">3.1.2 ChipLink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fpga-side-block-design">3.1.3 FPGA-side Block Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ddr-read-and-write-test">3.1.4  DDR Read and Write Test</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#preface">3.2 Preface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#notation-conventions">3.2.1 Notation Conventions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#supported-tools-and-environment-set-up">3.2.2 Supported Tools and Environment Set Up</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sw-requirements">3.2.2.1 SW Requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hw-requirements">3.2.2.2 HW Requirements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#introduction">3.3 Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prototype-architecture">3.4 Prototype Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#top-level-architecture">3.4.1 Top Level Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clock-and-reset">3.4.2 Clock and Reset</a></li>
<li class="toctree-l4"><a class="reference internal" href="#peripheral-architecture">3.4.3  Peripheral Architecture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chiplink-module">3.4.4 Chiplink Module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mapping-of-main-memory">3.5 Mapping of Main Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-on-board-ddr3-memory">3.5.1 Using on-Board DDR3 Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#added-iram-module">3.5.2 Added IRAM Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sd-card-as-external-memory">3.5.3 SD Card as External Memory</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#boot-mode-and-serial-terminal-settings">3.6 Boot mode and Serial terminal settings</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#start-up-process">3.6.1 Start-up Process</a></li>
<li class="toctree-l4"><a class="reference internal" href="#boot-mode-setup">3.6.2 Boot Mode Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#serial-terminal-setup">3.6.3 Serial Terminal Setup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#prototype-operation">3.7 Prototype Operation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reset-sequence">3.7.1 Reset Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#booting-os-from-an-sd-card">3.7.2 Booting OS from an SD Card</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simulation-and-debugging">3.8 Simulation and Debugging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#software-simulation-from-vivado">3.8.1 Software Simulation from Vivado</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inserting-debug-cores-for-logic-analyzer">3.8.2  Inserting Debug Cores for Logic Analyzer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#block-design">3.9  Block Design</a></li>
<li class="toctree-l3"><a class="reference internal" href="#about-networking">3.10 About Networking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generating-an-sd-bootable-image">3.11 Generating an SD-Bootable Image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compile-the-rom-boot-program">3.12 Compile the ROM boot program</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#backend">4. Backend</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#memory">4.1 Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memory-technical-specification">4.1.1 Memory Technical Specification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id48">4.1.2 Theory of Operation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#i-o-cells-selections">4.2 I/O Cells Selections</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i-o-cell-type-selection">4.2.1 I/O Cell Type Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#selection-of-specific-i-o-cells">4.2.2 Selection of Specific I/O Cells</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-truth-table-for-i-o-selection">4.2.3 The truth table for I/O selection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#device-sd">5. DEVICE(SD)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sd-technical-specification">5.1 SD Technical Specification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id51">Description</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id52">Features</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id53">5.2 Theory of Operation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spi-mode">SPI Mode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#power-on">Power-on</a></li>
<li class="toctree-l4"><a class="reference internal" href="#receiving-commands">Receiving Commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#responding-to-commands">Responding to Commands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#card-initialisation">Card Initialisation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clock-and-phase">Clock and Phase</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sd-card-design-verification">5.3 SD Card Design Verification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id54">Goals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id56">Design features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stimulus-strategy">Stimulus strategy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#self-checking-strategy">Self-checking strategy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id59">5.3.1 Testplan</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id60">5.4 Hardware Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sd-card-i-o">5.4.1 SD card I/O</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id61">5.5 Registers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#two-dimensional-array">two-dimensional array</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id62">5.6 Checklist</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#design">Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#verify">Verify</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">test1</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">MEISHAV</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/pages/study.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="meishav">
<h1>MEISHAV<a class="headerlink" href="#meishav" title="Link to this heading"></a></h1>
<section id="start">
<h2>1. START<a class="headerlink" href="#start" title="Link to this heading"></a></h2>
<section id="project">
<h3>1.1 Project<a class="headerlink" href="#project" title="Link to this heading"></a></h3>
<p>Design of a reconfigurable multi-core heterogeneous processor utilising RISC-V architecture.</p>
<div align=center>  
<img src="photo/image-7.png" width="500"  alt="UART">      <p>Design Architecture</p>
<div>
<div align=left><div> <section id="memory-map">
<h4>Memory Map<a class="headerlink" href="#memory-map" title="Link to this heading"></a></h4>
<p>Base | Size（B） | Description | Notes|
:———–: | :———–: | :———–: | :———–:|
0x0000_0000 | 4K | debug-controller |
0x0000_3000 | 4K | error-device |
0x0001_0000 | 8K | Mask ROM (32 KiB) |
0x0200_0000 | 64K | CLINT |<br />0x0C00_0000 | 4M | PLIC |<br />0x5000_0000 | 0x6000_0000(256M) | PCIE HOST 空间 |<br />0x5000_0000 | 512K | on chip sram |<br />0x5100_0000 | 4K | soc_lsys |<br />0x5200_0000 | 4K | spi_1 |<br />0x6000_0000 | 0x6400_0000 | TIMEOUT |<br />0x20_0000_0000 | 0x20_0800_0000/128M | pci ctrl 空间 timeout |<br />0x20_0800_0000 | 0x20_1000_0000 | TIME_OUT |<br />0x20_1000_0000 | 0x21_000_0000 | TIME_OUT |<br />0x21_0000_0000 | 0x3F_FFFF_FFFF | TIME_OUT |<br />0x6400_0000 | 4K | serial | 不支持narrow，sparse
0x6400_1000 | 4K | spi_0 | 不支持narrow，sparse
0x6400_2000 | 4K | gpio | 不支持narrow，sparse
0x8000_0000 | 512M | CHIPLINK |
0xA000_0000 | 512M | DDR（SDRAM） |<br />0xC000_0000 | 1G | TIME_OUT | 注意到这段空间不允许访问，访问会导致总线挂死
MIG_CHIPLINK_SLAVE | 1 MIG真实空间0x8000_0000 - 0xC000_0000可remap到如下空间：0x1000_<em>0000 - 0xE000_0000</em>（13*256=3328M） | 1 slave口需要地址remap，最高4bit可以控制，连接到SOC_LSYS，默认最高4bit改成1 | 集成chiplink到meishav100版本，用于后续验证<a class="reference external" href="https://g-ntwx0319.coding.net/p/v100/assignments/issues/32/detail">https://g-ntwx0319.coding.net/p/v100/assignments/issues/32/detail</a></p>
</section>
</section>
<section id="background">
<h3>1.2 Background<a class="headerlink" href="#background" title="Link to this heading"></a></h3>
<p>The demand for artificial intelligence computing power in unmanned systems has surged significantly, rendering traditional isomorphic computing systems inadequate for the requirements. Multi-core heterogeneous processors have garnered substantial attention due to their formidable computing capabilities. Simultaneously, RISC-V, as a fully open-source instruction set architecture, empowers us to design our own CPUs entirely.</p>
</section>
<section id="goal">
<h3>1.3 Goal<a class="headerlink" href="#goal" title="Link to this heading"></a></h3>
<p>Design a dispatch chip for unmanned systems with high performance and rich peripherals. At the same time, the chip also has reconfigurable characteristics, that is,appropriate CPU and peripheral configurations can be chosen according to different upper-layer applications to improve computational efficiency.</p>
<div align=center><img src="photo/image-16.png" width="300"  alt="2">  <p>Standalone Chip</p>
<div>
<div align=left><div>   </section>
</section>
<section id="hardware">
<h2>2. Hardware<a class="headerlink" href="#hardware" title="Link to this heading"></a></h2>
<div align=center><img src="photo/image-26.png" width="600"   
 alt="2">  
Completion
<div>
<div align=left><div>        <p>The table below provides a list of the hardware modules we currently possess:</p>
<p>| Design | Spec Version |
| :—: | :—: |
| GPIO | 1.1.0 |
| SPI | 1.1.0 |
| QSPI | 1.1.0 |
| UART | 1.1.0 |
| JTAG | 1.1.0|<br />|SRAM|1.1.0|</p>
<ul class="simple">
<li><p>The chip incorporates GPIO peripherals, which facilitate bidirectional communication with the external environment.</p></li>
<li><p>The chip features two SPIs and one QSPI, supporting both single-wire and four-wire modes, and is employed for communication with external devices, such as SD cards.</p></li>
<li><p>The chip includes a UART peripheral, which implements dual-lane full-duplex UART functionality.</p></li>
<li><p>The chip houses a JTAG port. By interfacing with the JTAG pins, the logic within the debug module enables the core to enter debug mode, affording the ability to inject code either into the device—through instruction emulation—or directly into memory.</p></li>
</ul>
<section id="gpio">
<h3>2.1 GPIO<a class="headerlink" href="#gpio" title="Link to this heading"></a></h3>
<section id="gpio-technical-specification">
<h4>2.1.1 GPIO Technical Specification<a class="headerlink" href="#gpio-technical-specification" title="Link to this heading"></a></h4>
<p><img alt="alt text" src="../_images/image-20.png" /></p>
<section id="description">
<h5>Description<a class="headerlink" href="#description" title="Link to this heading"></a></h5>
<p>The GPIO module facilitates software communication through general-purpose I/O pins with a high degree of flexibility. Each of the 32 individual bits can be configured as peripheral outputs using two distinct modes. Similarly, each of these 32 bits can be accessed by software as peripheral inputs. The connectivity of these peripheral inputs and outputs to the chip’s I/O pins is beyond the scope of this document. Refer to the Comportability Specification for detailed peripheral I/O options at the top chip level.</p>
<p>In the output configuration, this module offers direct 32-bit access to each GPIO value via direct write functionality. This mode empowers software to control all GPIO bits simultaneously. Alternatively, the module supports masked writes, which allow software to update half of the bits at once, enabling the modification of a subset of the output values without necessitating a read-modify-write sequence. In this mode, the user specifies a mask indicating which of the 16 bits are to be altered, along with their new values. Detailed operation of this mode is elucidated in the Programmers Guide.</p>
<p>For input operations, software can read the status of any GPIO peripheral input. Additionally, software can configure interrupt events for any of the 32 bits, with options including positive edge, negative edge, or level detection. A noise filter can be enabled for any of the 32 GPIO inputs, requiring the input to remain stable for 16 module clock cycles before the input register acknowledges the change and evaluates interrupt generation. It is important to note that if the filter is activated and the pin is designated as an output, there will be a corresponding delay in reflecting output changes in the input register.</p>
<p>For in-depth insights into output, input, and interrupt control mechanisms, please consult the Design Details section.</p>
</section>
<section id="features">
<h5>Features<a class="headerlink" href="#features" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p>32 General Purpose Input/Output (GPIO) ports</p></li>
<li><p>Configurable interrupt capability for each GPIO, supporting rising edge, falling edge, or active low/high input detection</p></li>
<li><p>Dual methods for updating GPIO output: direct write and masked (thread-safe) update</p></li>
</ul>
</section>
</section>
<section id="theory-of-operation">
<h4>2.1.2 Theory of Operation<a class="headerlink" href="#theory-of-operation" title="Link to this heading"></a></h4>
<section id="gpio-output">
<h5>2.1.2.1 GPIO Output<a class="headerlink" href="#gpio-output" title="Link to this heading"></a></h5>
<p>The GPIO module maintains a single 32-bit output register, DATA_OUT, with two methods of write access. Direct write access utilizes DIRECT_OUT, while masked write access employs MASKED_OUT_UPPER and</p>
<p>MASKED_OUT_LOWER. Direct access allows full read and write capabilities for all 32 bits within one register.</p>
<p>For masked access, the bits to be modified are specified as a mask in the upper 16 bits of the MASKED_OUT_UPPER and MASKED_OUT_LOWER register writes, with the data to be written provided in the lower 16 bits of the register write. The hardware updates DATA_OUT according to this mask, enabling modifications without requiring software to perform a Read-Modify-Write operation.</p>
<p>Reads from masked registers return the lower or upper 16 bits of the DATA_OUT contents, with zeros returned in the upper 16 bits (mask field). To read the values on the pins, software should access the DATA_IN register. (Refer to the GPIO Input section below).</p>
<p>This same concept is applied to the output enable register, DATA_OE. Direct access uses DIRECT_OE, and masked access is facilitated through MASKED_OE_UPPER and MASKED_OE_LOWER. The output enable is transmitted to the pad control block to determine whether the pad should drive the DATA_OUT value to the associated pin.</p>
<p>A typical usage pattern involves initializing and suspending/resuming code utilizing the full access registers to set the output enables and current output values, before switching to masked access for both DATA_OUT and DATA_OE.</p>
<p>For GPIO outputs that are not in use (either not connected to a pin output or not selected for pin multiplexing), the output values are disconnected and have no impact on the GPIO input, regardless of the output enable settings.</p>
</section>
<section id="gpio-input">
<h5>2.1.2.2 GPIO Input<a class="headerlink" href="#gpio-input" title="Link to this heading"></a></h5>
<p>The DATA_IN register provides the contents as observed on the peripheral input, usually from the pads connected to these inputs. In the presence of a pin-multiplexing unit, GPIO peripheral inputs not connected to a chip input will be tied to a constant zero input.</p>
<p>The GPIO module offers optional independent noise filter control for each of the 32 input signals. Each input can be independently enabled with the CTRL_EN_INPUT_FILTER (one bit per input). This 16-cycle filter is applied to both the DATA_IN register and the interrupt detection logic. The timing for DATA_IN remains non-instantaneous if CTRL_EN_INPUT_FILTER is false due to top-level routing, but no flops are present between the chip input and the DATA_IN register.</p>
<p>The contents of DATA_IN are always readable and reflect the value seen at the chip input pad, irrespective of the output enable setting from DATA_OE. If the output enable is true (and the GPIO is connected to a chip-level pad), the value read from DATA_IN includes the effect of the peripheral’s driven output (thus differing from DATA_OUT only if the output driver is unable to switch the pin or during the delay imposed if the noise filter is enabled).</p>
</section>
<section id="interrupts">
<h5>2.1.2.3 Interrupts<a class="headerlink" href="#interrupts" title="Link to this heading"></a></h5>
<p>The GPIO module provides 32 interrupt signals to the main processor. Each interrupt can be independently enabled, tested, and configured. Following the standard interrupt guidelines in the Comportability Specification, the 32 bits of the INTR_ENABLE register determine whether the associated inputs are configured to detect interrupt events. If enabled via the various INTR_CTRL_EN registers, their current state can be read in the INTR_STATE register. Clearing is achieved by writing a 1 into the associated INTR_STATE bit field.</p>
<p>For configuration, four types of interrupts are available per bit, controlled with four control registers. INTR_CTRL_EN_RISING configures the associated input for rising-edge detection. Similarly, INTR_CTRL_EN_FALLING detects falling edge inputs. INTR_CTRL_EN_LVLHIGH and INTR_CTRL_EN_LVLLOW allow the input to be level-sensitive interrupts. Theoretically, an input can be configured to detect both rising and falling edges, but there is no hardware assistance to indicate which edge caused the output interrupt.</p>
<p><strong>Note #1</strong>: The interrupt can only be triggered by GPIO input. <strong>Note #2</strong>: All inputs are subject to optional noise filtering before being sent into interrupt detection. <strong>Note #3</strong>: All interrupts to the processor are level interrupts as per the Comportability Specification guidelines. The GPIO module, if configured, converts an edge detection into a level interrupt to the processor core.</p>
</section>
</section>
</section>
<section id="uart">
<h3>2.2 UART<a class="headerlink" href="#uart" title="Link to this heading"></a></h3>
<section id="uart-technical-specification">
<h4>2.2.1 UART Technical Specification<a class="headerlink" href="#uart-technical-specification" title="Link to this heading"></a></h4>
<p><img alt="alt text" src="../_images/image-21.png" /></p>
<section id="id1">
<h5>Description<a class="headerlink" href="#id1" title="Link to this heading"></a></h5>
<p>UART is a universal serial data bus designed for asynchronous communication. The bidirectional nature of the bus facilitates full-duplex transmission and reception. UART operates by transmitting data bits one by one. Typically, three wires are utilised to complete the communication: the transmission line (TX), the reception line (RX), and the ground line (GND). The TX and RX of both parties must be cross-connected, while the GND can be connected for normal communication.</p>
</section>
<section id="id2">
<h5>Features<a class="headerlink" href="#id2" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p>2-pin full-duplex external interfaces</p></li>
<li><p>8-bit data word, optional even or odd parity bit per byte</p></li>
<li><p>1 stop bit</p></li>
<li><p><font color=black>32 x 8b RX buffer(不知道我们UART buffer的深度是不是32) </font></p></li>
<li><p><font color=black>32 x 8b TX buffer(不知道我们UART buffer的深度是不是32) </font></p></li>
<li><p>Programmable baud rate</p></li>
</ul>
</section>
</section>
<section id="id3">
<h4>2.2.2 Theory of Operation<a class="headerlink" href="#id3" title="Link to this heading"></a></h4>
<section id="communication-protoco">
<h5>Communication Protoco<a class="headerlink" href="#communication-protoco" title="Link to this heading"></a></h5>
<p>During idle periods, the TX/RX serial lines maintain a high state. Data transmission commences with a START bit, when the high idle state transitions from 1 to 0, followed by 8 data bits. The least significant bit is transmitted first. If the parity feature is enabled, an odd or even parity bit is inserted after the data bits. Conclusively, a STOP bit, maintained at logic 1, signifies the completion of one byte of data transfer.</p>
<div align=center><img src="photo/image-6.png" width="600"  alt="2">  <div>
<div align=left><div>    </section>
<section id="transmission">
<h5>Transmission<a class="headerlink" href="#transmission" title="Link to this heading"></a></h5>
<p>Writing to <code class="docutils literal notranslate"><span class="pre">WDATA</span></code>register enqueues a data byte into the 32-byte deep write FIFO, thereby triggering the transmit module to initiate UART TX serial data transfer. The TX module dequeues the byte from the FIFO and shifts it bit by bit onto the UART TX pin on the positive edges of the baud clock.</p>
<p>In the event that TX is not enabled, data written into the FIFO will be accumulated and transmitted once TX is enabled.</p>
<p>Upon the FIFO becoming empty as part of the transmission process, a TX FIFO done interrupt will be generated when the final byte has completed transmission. This interrupt is distinct from the TX FIFO watermark interrupt.</p>
</section>
<section id="reception">
<h5>Reception<a class="headerlink" href="#reception" title="Link to this heading"></a></h5>
<p>The RX module oversamples the RX input pin at 16 times the requested baud rate. Upon detecting a low state on the input, the receiver verifies that the line remains low half a bit-time later  to confirm the START bit. If the line returns to a high state, the potential glitch is disregarded. After identifying the START bit, the RX module samples at the center of each bit-time, collecting incoming serial bits into a character buffer. If the STOP bit is detected as high and the optional parity bit is correct, the data byte is enqueued into the 32-byte deep RX FIFO. The data can then be retrieved by reading the <code class="docutils literal notranslate"><span class="pre">RDATA</span></code> register.</p>
</section>
</section>
<section id="design-verification">
<h4>2.2.3 Design Verification<a class="headerlink" href="#design-verification" title="Link to this heading"></a></h4>
<section id="goals">
<h5>Goals<a class="headerlink" href="#goals" title="Link to this heading"></a></h5>
<section id="dv">
<h6>DV<a class="headerlink" href="#dv" title="Link to this heading"></a></h6>
<p>Verify UART IP features by running dynamic simulations with a SV/UVM based testbench</p>
</section>
</section>
<section id="design-features">
<h5>Design features<a class="headerlink" href="#design-features" title="Link to this heading"></a></h5>
<p>For detailed information on UART design features, please see the <strong>UART Technical Specification</strong>.</p>
</section>
<section id="testbench-architecture">
<h5>Testbench architecture<a class="headerlink" href="#testbench-architecture" title="Link to this heading"></a></h5>
<section id="top-level-testbench">
<h6>Top level testbench<a class="headerlink" href="#top-level-testbench" title="Link to this heading"></a></h6>
<p>Top level testbench is located at /trunk/hw/d2dv100_top/dv/dut_MEISHAV100_TOP_wrapper.sv. It instantiates the TOP DUT module /trunk/hw/d2dv100_top/rtl/top/MEISHAV100_TOP.sv. In addition, it instantiates the following interfaces, connects them to the DUT and sets their handle into <code class="docutils literal notranslate"><span class="pre">uvm_config_db</span></code>:</p>
<ul class="simple">
<li><p>Clock and reset interface</p></li>
<li><p>Tilelink host interface</p></li>
<li><p>UART IOs</p></li>
</ul>
</section>
</section>
<section id="global-types-methods">
<h5>Global types &amp; methods<a class="headerlink" href="#global-types-methods" title="Link to this heading"></a></h5>
<p>All common types and methods defined at the package level can be found in <code class="docutils literal notranslate"><span class="pre">uart_env_pkg</span></code></p>
</section>
<section id="tl-agent">
<h5>TL_agent<a class="headerlink" href="#tl-agent" title="Link to this heading"></a></h5>
<p>UART instantiates <code class="docutils literal notranslate"><span class="pre">tl_agent</span></code> which provides the ability to drive and independently monitor random traffic via TL host interface into UART device.</p>
</section>
<section id="uart-agent">
<h5>UART_agent<a class="headerlink" href="#uart-agent" title="Link to this heading"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">UART</span> <span class="pre">agent</span></code> is used to drive and monitor UART items, which also provides basic coverage on data, parity, baud rate etc. These baud rates are supported: 9600, 115200, 230400, 1Mbps(1048576), 2Mbps(2097152)</p>
</section>
</section>
<section id="testplan">
<h4>2.2.3.1 Testplan<a class="headerlink" href="#testplan" title="Link to this heading"></a></h4>
<p>This validation environment encompasses a substantial amount of supplementary code; however, the parent classes may introduce anomalies or superfluous functionalities. Consequently, it is permissible to directly alter the inherited parent class to the corresponding UVM base class, as necessitated</p>
<section id="develop-an-agent">
<h5>2.2.3.1.1 Develop an agent<a class="headerlink" href="#develop-an-agent" title="Link to this heading"></a></h5>
<p>In the environment written this time, <code class="docutils literal notranslate"><span class="pre">uart</span></code>, as <code class="docutils literal notranslate"><span class="pre">slave_agent</span></code>, is driven by soc, so uart_agent only contains a driver, which is used to collect signals from the uart port during the test.</p>
<section id="uart-agent-cfg-sv">
<h6>uart_agent_cfg.sv<a class="headerlink" href="#uart-agent-cfg-sv" title="Link to this heading"></a></h6>
<p>The baud rate, parity check bit and other attributes of uart are defined, and a uart interface is declared for monitor to collect data. There are 7 functions in this file, which are:<code class="docutils literal notranslate"><span class="pre">set_uart_period_glitch_pct、get_uart_period_glitch_pct、set_baud_rate、set_parity、set_max_drift_cycle_pct、get_max_drift_cycle_pct、reset_asserted、reset_deasserted</span></code>.</p>
</section>
<section id="uart-agent-pkg-sv">
<h6>uart_agent_pkg.sv<a class="headerlink" href="#uart-agent-pkg-sv" title="Link to this heading"></a></h6>
<p>The library and files used by uart_agent are imported, and some enumerated variables are defined, such as BaudRate(baud rate), transmission direction (single, dual, quad), etc., which is convenient for us to use.</p>
</section>
<section id="uart-agent-sv">
<h6>uart_agent.sv<a class="headerlink" href="#uart-agent-sv" title="Link to this heading"></a></h6>
<p>A <code class="docutils literal notranslate"><span class="pre">uart_monitor</span></code> and <code class="docutils literal notranslate"><span class="pre">uart_agent_config</span></code> are defined, <code class="docutils literal notranslate"><span class="pre">uart_if</span></code> as set in <code class="docutils literal notranslate"><span class="pre">config_db</span></code> is passed to<code class="docutils literal notranslate"> <span class="pre">cfg.uart_if</span></code>, and <code class="docutils literal notranslate"><span class="pre">uart_cfg</span></code> is set to the database.</p>
</section>
<section id="uart-driver-sv">
<h6>uart_driver.sv<a class="headerlink" href="#uart-driver-sv" title="Link to this heading"></a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">uart_driver</span></code> class inherits from <code class="docutils literal notranslate"><span class="pre">dv_base_driver</span></code> and is used to drive transmission and receive operations in the simulation environment of UART. It is responsible for getting the data item <code class="docutils literal notranslate"><span class="pre">uart_item</span></code> from the sequencer and driving it to the UART interface. This class mainly simulates the receiving process of data by controlling the received signal of the UART interface<code class="docutils literal notranslate"><span class="pre">uart_rx</span></code>.</p>
</section>
<section id="main-tasks-and-functions">
<h6>Main tasks and functions:<a class="headerlink" href="#main-tasks-and-functions" title="Link to this heading"></a></h6>
<p><code class="docutils literal notranslate"><span class="pre">run_phase</span></code>:<br /><code class="docutils literal notranslate"><span class="pre">run_phase</span></code> is one of the UVM simulation phases, in which the driver first calls the <code class="docutils literal notranslate"><span class="pre">reset_signals</span></code> method to reset the UART interface signal, and then enters the<code class="docutils literal notranslate"> <span class="pre">get_and_drive</span></code>task, continuously fetching data from the sequencer and driving the transmission.</p>
<p><code class="docutils literal notranslate"><span class="pre">reset_signals</span></code>:<br />This task is used to reset the UART received signal (’ uart_rx ‘) to ensure that the signal is in a known state at the start of the simulation.
<code class="docutils literal notranslate"><span class="pre">set_rx</span></code> :
The <code class="docutils literal notranslate"><span class="pre">set_rx</span></code> task is responsible for setting the value of the received signal (<code class="docutils literal notranslate"><span class="pre">uart_rx</span></code>) of the UART, while randomly introducing some small amplitude signal failures (usually 10% of the clock cycle) according to the configuration. This function is used to simulate the signal jitter and faults that may exist in real hardware, so as to test the fault tolerance of the system to these abnormal conditions.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_and_drive</span></code>:<br />This task takes the data item (<code class="docutils literal notranslate"><span class="pre">uart_item</span></code>) from the sequencer (<code class="docutils literal notranslate"><span class="pre">seq_item_port</span></code>) and drives it to the UART interface based on the information in the configuration and request.<br />If parity is enabled (<code class="docutils literal notranslate"><span class="pre">en_parity</span></code>) or the parity configuration is overridden in the request (<code class="docutils literal notranslate"> <span class="pre">ovrd_en_parity</span></code>), it transmits all data bits including the parity bits to the ‘uart_rx’ signal.
This task also handles the situation during a reset, and if a reset signal is detected, the currently transmitted data item is abandoned.</p>
<p><code class="docutils literal notranslate"><span class="pre">wait_uart_rx_cycle</span></code>:<br />The <code class="docutils literal notranslate"><span class="pre">wait_uart_rx_cycle</span></code> task is used to wait for the next clock cycle when the UART receives a signal. This can be done by waiting for the callback function (<code class="docutils literal notranslate"><span class="pre">drv_rx_cb</span></code>) in the simulation environment or by detecting the reset signal.
The task monitors the reset signal or UART clock event through the <code class="docutils literal notranslate"><span class="pre">fork</span></code> mechanism and chooses to end the current cycle based on the simulation.</p>
</section>
<section id="uart-if-sv">
<h6>uart_if.sv<a class="headerlink" href="#uart-if-sv" title="Link to this heading"></a></h6>
<p>The uart interface provides data for the monitor. Contains the 2 basic signals of uart and some signals for debugging.</p>
</section>
<section id="uart-item-sv">
<h6>uart_item.sv<a class="headerlink" href="#uart-item-sv" title="Link to this heading"></a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">uart_item</span></code> class is a UVM class that inherits from <code class="docutils literal notranslate"><span class="pre">uvm_sequence_item</span></code> and represents the basic data unit that is transferred in UART communication. This class defines the basic structure of a UART packet, including the start bit, stop bit, data, parity and other information, and provides some constraints and methods to control the randomization and use of these fields.</p>
</section>
<section id="uart-monitor-sv">
<h6>uart_monitor.sv<a class="headerlink" href="#uart-monitor-sv" title="Link to this heading"></a></h6>
<p><code class="docutils literal notranslate"><span class="pre">tx_analysis_port</span></code>and <code class="docutils literal notranslate"><span class="pre">rx_analysis_port</span></code> are used to collect data transmitted and received by the UART respectively and to pass this data to the <code class="docutils literal notranslate"><span class="pre">scoreboard</span></code> for further analysis and verification.</p>
</section>
<section id="id4">
<h6>Main tasks and functions:<a class="headerlink" href="#id4" title="Link to this heading"></a></h6>
<p><code class="docutils literal notranslate"><span class="pre">collect_tx_data</span></code>：<br />This task monitors the UART transmission signal (<code class="docutils literal notranslate"><span class="pre">uart_tx</span> </code>) and collects data for each transmission. When <code class="docutils literal notranslate"><span class="pre">uart_tx</span></code> is low and <code class="docutils literal notranslate"><span class="pre">tx_monitor</span></code> is enabled, the data collection process begins.</p>
<p>The collection process consists of getting the start bit, the data bit, the check bit (if enabled), and finally the stop bit. Each bit is collected via a callback function of the monitor interface.
After the collection is complete, the task checks whether the check bit is correct and passes the collected data to the tx_analysis_port for further analysis by the scoreboard.</p>
<p><code class="docutils literal notranslate"><span class="pre">collect_rx_data</span></code>：<br />This task monitors the UART reception signal (<code class="docutils literal notranslate"><span class="pre">uart_rx</span></code>) and collects data on each reception. Similar to the <code class="docutils literal notranslate"><span class="pre">collect_tx_data</span></code>task, data collection begins when <code class="docutils literal notranslate"><span class="pre">uart_rx</span></code> is low and <code class="docutils literal notranslate"><span class="pre">rx_monitor</span></code> is enabled.<br />The collection process consists of getting the start bit, the data bit, the check bit (if enabled), and finally the stop bit. The collection of each bit is also done through the callback function of the monitor interface.<br />After the collection is complete, the task checks whether the check bit is correct and passes the collected data to the rx_analysis_port for further analysis by the scoreboard.<br /><code class="docutils literal notranslate"><span class="pre">drive_tx_clk</span></code> and <code class="docutils literal notranslate"><span class="pre">drive_rx_clk</span></code>:</p>
<p><code class="docutils literal notranslate"><span class="pre">drive_tx_clk</span></code>and<code class="docutils literal notranslate"><span class="pre">drive_rx_clk</span></code>are used to drive the transmission and reception of the clock signal of the UART, respectively, to ensure that the data is collected within the correct clock cycle.</p>
<p><code class="docutils literal notranslate"><span class="pre">mon_tx_stable</span></code>:<br />The <code class="docutils literal notranslate"><span class="pre">mon_tx_stable</span></code> task is responsible for monitoring the stability of the UART transmitted signal and checking whether the signal remains stable for a specified clock period.</p>
<p><code class="docutils literal notranslate"><span class="pre">process_reset</span></code>:<br /><code class="docutils literal notranslate"><span class="pre">process_reset</span></code> are used to reset the UART. During the reset, data collection is stopped. After the reset is complete, the data collection process is restarted.</p>
</section>
<section id="uart-logger-sv">
<h6>uart_logger.sv<a class="headerlink" href="#uart-logger-sv" title="Link to this heading"></a></h6>
<p>The uart_logger class is a UVM component that inherits from the uvm_component and is used to capture the log data transferred from the UART and store it in a log file or print it in a simulation log.</p>
</section>
<section id="uart-base-agent-core">
<h6>uart_base_agent.core<a class="headerlink" href="#uart-base-agent-core" title="Link to this heading"></a></h6>
<p><code class="docutils literal notranslate"><span class="pre">.core</span> </code>file is the configuration file that fusesoc uses to manage the project and can copy other written files and then make changes to several parts.</p>
</section>
</section>
<section id="develop-an-env">
<h5>2.2.3.1.2 Develop an env<a class="headerlink" href="#develop-an-env" title="Link to this heading"></a></h5>
<section id="uart-scoreboard-sv">
<h6>uart_scoreboard.sv<a class="headerlink" href="#uart-scoreboard-sv" title="Link to this heading"></a></h6>
<p>Define four queues to store the expected and actual write data and read data. The expected data is obtained from the tl-agent, and the actual data is obtained from the uart-agent. Retrieve the uart data using <code class="docutils literal notranslate"><span class="pre">uvm_blocking_get_port</span></code> and compare the expected data with the actual data. However, the current scoreboard has some problems and is not used in the current validation environment.</p>
</section>
<section id="uart-env-sv">
<h6>uart_env.sv<a class="headerlink" href="#uart-env-sv" title="Link to this heading"></a></h6>
<p><code class="docutils literal notranslate"><span class="pre">uart_agent,</span> <span class="pre">uart_agent_cfg,</span> <span class="pre">uart_scoreboard,</span> <span class="pre">and</span> <span class="pre">uvm_tlm_analysis_fifo</span></code> (connecting uart_scoreboard and uart_monitor) are defined.</p>
</section>
<section id="uart-env-pkg-sv">
<h6>uart_env_pkg.sv<a class="headerlink" href="#uart-env-pkg-sv" title="Link to this heading"></a></h6>
<p>The libraries and files used by uart_env are imported.</p>
</section>
<section id="uart-base-env-core">
<h6>uart_base_env.core<a class="headerlink" href="#uart-base-env-core" title="Link to this heading"></a></h6>
<p>The configuration file for uart_env, which provides dependencies for uart_test.</p>
</section>
</section>
<section id="develop-an-sequence">
<h5>2.2.3.1.3 Develop an sequence<a class="headerlink" href="#develop-an-sequence" title="Link to this heading"></a></h5>
<section id="seq-lib-sv">
<h6>seq_lib.sv<a class="headerlink" href="#seq-lib-sv" title="Link to this heading"></a></h6>
<p>Base sequence of uart. The current environment uses uart_item in the agent folder that is the same as this sequence. Therefore, this file is not used currently.</p>
</section>
</section>
<section id="develop-an-test">
<h5>2.2.3.1.4 Develop an test<a class="headerlink" href="#develop-an-test" title="Link to this heading"></a></h5>
<section id="uart-test-sv">
<h6>uart_test.sv<a class="headerlink" href="#uart-test-sv" title="Link to this heading"></a></h6>
<p>The test is modified by referring to the tl-test written in the environment.</p>
</section>
<section id="uart-macros-svh">
<h6>uart_macros.svh<a class="headerlink" href="#uart-macros-svh" title="Link to this heading"></a></h6>
<p>The register base address and offset of uart are defined for our convenience.</p>
</section>
<section id="uart-test-v">
<h6>uart_test.v<a class="headerlink" href="#uart-test-v" title="Link to this heading"></a></h6>
<p>Refer to <code class="docutils literal notranslate"><span class="pre">tlul_test.sv</span></code> to write, mainly to change the <code class="docutils literal notranslate"><span class="pre">main_phase</span></code> code. The rest just defines a <code class="docutils literal notranslate"><span class="pre">uart_if</span></code> in <code class="docutils literal notranslate"><span class="pre">uart_base_test_cfg</span></code> and a <code class="docutils literal notranslate"><span class="pre">uart_env</span></code> in <code class="docutils literal notranslate"><span class="pre">uart_base_test</span></code>.</p>
</section>
<section id="uart-interface-definition">
<h6>UART interface definition：<a class="headerlink" href="#uart-interface-definition" title="Link to this heading"></a></h6>
<p>The uart_if interface is defined in the <code class="docutils literal notranslate"><span class="pre">uart_base_test_cfg</span></code> for communicating with the UART environment.<br />The UART environment is initialized：<br />Initialize the <code class="docutils literal notranslate"><span class="pre">uart_env</span></code> environment in uart_base_test, which is responsible for configuring and monitoring the behavior of the UART.</p>
</section>
<section id="register-configuration">
<h6>Register configuration：<a class="headerlink" href="#register-configuration" title="Link to this heading"></a></h6>
<p>In <code class="docutils literal notranslate"><span class="pre">main_phase</span></code>, data is written to the register of the UART mainly through the TileLink (TL) protocol agent (<code class="docutils literal notranslate"><span class="pre">TL-agent</span> </code>) to complete the register configuration. Compared with the Register Abstraction layer (RAL), TL-agent can interact with hardware more directly and is suitable for lower-level verification scenarios.</p>
<p>Use TL-agent to configure UART control registers, including <code class="docutils literal notranslate"><span class="pre">DIV</span></code>, <code class="docutils literal notranslate"><span class="pre">TXCTRL</span></code>, <code class="docutils literal notranslate"><span class="pre">RXCTRL</span></code> and so on.
After the configuration, the TL-agent writes the generated data to <code class="docutils literal notranslate"><span class="pre">uart_txfifo</span></code>.</p>
</section>
</section>
</section>
<section id="hardware-interfaces">
<h4>2.2.4 Hardware Interfaces<a class="headerlink" href="#hardware-interfaces" title="Link to this heading"></a></h4>
<p>The following table shows the uart connection method:<br />|Master_Port|Slave_Port|<br />|:-:|:-:|<br />|Master_Tx|Slave_Rx|<br />|Master_Rx|Slave_Tx|<br />|GND|GND|</p>
<p>The following diagram shows the system block diagram of UART：</p>
<div align=center><img src="photo/image-1.png" width="280"  alt="2">  <p>Block Diagram</p>
<div>
<div align=left><div>   </section>
<section id="registers">
<h4>2.2.5 Registers<a class="headerlink" href="#registers" title="Link to this heading"></a></h4>
<section id="control-register">
<h5>Control Register<a class="headerlink" href="#control-register" title="Link to this heading"></a></h5>
<p>A serial port control register is a specialized type of register within communication interfaces, responsible for managing the configuration and control of serial communication lines. These registers are essential for facilitating and overseeing data transfers between devices that employ serial communication protocols.
offset | Name | Description
:———–: | :———–: | :———–:|
0x00 | txdata | Transmit data register
0x04 | rxdata | Receiver data register
0x08 | txctrl | Transmit control register
0x0C | rxctrl | Receive control register
0X10 | ie | UART interrupt enable
0X14 | ip | UART interrupt pending
0X18 | div | Baud rate divisor</p>
<p>The functions typically managed by these registers include:</p>
</section>
<section id="baud-rate-divisor-register-div">
<h5>Baud Rate Divisor Register(div)<a class="headerlink" href="#baud-rate-divisor-register-div" title="Link to this heading"></a></h5>
<p>It determines the speed of data transmission in bits per second (baud). The div register designates the divisor employed for the baud rate generation of the Tx and Rx channels. The input clock is derived from the bus clock. The reset value of the register is configured to div_init, and, given the anticipated frequency of the tlclk, it is calibrated to yield a 115200 baud output upon reset.</p>
<p>|tlclk (MHz) | Target Baud (Hz) | Divisor | Actual Baud (Hz) | Error (%)|<br />|:———–:| :———–: | :———–:| :———–:| :———–:
|500 | 31250 | 16000 | 31250 | 0|<br />|500 | 115200 | 4340 | 115207 | 0.0064|
|500 | 250000 | 2000 | 250000 | 0|
|500 | 1843200 | 271 | 1845018 | 0.099|
|750 | 31250 | 24000 | 31250 | 0|
|750 | 115200 | 6510 | 6510 | 0.0064|
|750 | 250000 | 3000 | 3000 | 0|
|750 | 1843200 | 407 | 407 | 0.024 |</p>
</section>
<section id="transmit-data-register-txdata">
<h5>Transmit Data Register (txdata)<a class="headerlink" href="#transmit-data-register-txdata" title="Link to this heading"></a></h5>
<p>If the FIFO is capable of accepting a new entry, then writing to the txdata register queues the characters contained within the data field to the transmitting FIFO. Reading from txdata returns the current value of the full flag and sets the data field to zero. The full flag signifies whether the transmitting FIFO can accommodate the new entry. Post-setting, writes to the data field are disregarded.
<strong>Bits</strong> | <strong>Field Name</strong> | <strong>Attr.</strong>
:———–: | :———–: | :———–:
[7:0] | data | RW
[30:8] | Reserved |<br />31 | full | RO</p>
</section>
<section id="receive-data-register-rxdata">
<h5>Receive Data Register (rxdata)<a class="headerlink" href="#receive-data-register-rxdata" title="Link to this heading"></a></h5>
<p>The read rxdata register extracts a character from the received FIFO and returns its value in the data field. The empty flag indicates whether the received FIFO is devoid of contents. Upon being set, the data field does not contain valid characters. Writes to rxdata are ignored.</p>
<p><strong>Bits</strong> | <strong>Field Name</strong> | <strong>Attr.</strong>
:———–: | :———–: | :———–:
[7:0] | data | RW
[30:8] | Reserved |<br />31 | full | RO</p>
</section>
<section id="interrupt-registers-ip-and-ie">
<h5>Interrupt Registers (ip and ie)<a class="headerlink" href="#interrupt-registers-ip-and-ie" title="Link to this heading"></a></h5>
<p>The ip register is a read-only register that indicates pending interrupt conditions, while the read-write ie register controls which UART interrupts are enabled. ie was reset to 0.
<strong>Bits</strong> | <strong>Field Name</strong> | <strong>Attr.</strong><br />:———–: | :———–: | :———–:<br />0 | txwm | RW<br />1 | rxwm | RW<br />[31:2] | Reserved |</p>
</section>
</section>
<section id="checklist">
<h4>2.2.6 Checklist<a class="headerlink" href="#checklist" title="Link to this heading"></a></h4>
<section id="design-checklist">
<h5>Design Checklist<a class="headerlink" href="#design-checklist" title="Link to this heading"></a></h5>
<p>|Type|Item|Resolution|<br />|:-:|:-:|:-:|
|Documentation|UART SPEC|Done|<br />|RTL|Design|Done|</p>
</section>
<section id="verification-checklist">
<h5>Verification Checklist<a class="headerlink" href="#verification-checklist" title="Link to this heading"></a></h5>
<p>|Type|Item|Resolution|<br />|:-:|:-:|:-:|
|Documentation|VIP|Done|<br />|RTL|Design|Done|</p>
</section>
</section>
</section>
<section id="spi">
<h3>2.3 SPI<a class="headerlink" href="#spi" title="Link to this heading"></a></h3>
<section id="spi-technical-specification">
<h4>2.3.1 SPI Technical Specification<a class="headerlink" href="#spi-technical-specification" title="Link to this heading"></a></h4>
<p><img alt="alt text" src="../_images/image-25.png" /></p>
<section id="id5">
<h5>Description<a class="headerlink" href="#id5" title="Link to this heading"></a></h5>
<p>The SPI controller supports single-, dual-, and quad-channel protocols in host-only mode. The baseline controller provides a FIFO-based interface for executing programmed input/output operations. Software initiates transfers by queuing frames into the transmit FIFO; upon completion, the slave responses are placed in the receive FIFO.</p>
<p>Additionally, the dedicated SPI0 controller implements an SPI flash read sequencer, which exposes the contents of an external SPI flash as a read-only/execute memory-mapped device. Given an input clock rate below 100 MHz and assuming the external SPI flash device supports the common Winbond/Numonyx serial read (0x03) command, the SPI0 controller resets to a state that allows memory-mapped reads. To enhance performance, consecutive accesses are automatically merged into a single long read command.</p>
<p>The fctrl register governs the toggling between memory-mapped and programmed I/O modes. In programmed I/O mode, memory-mapped reads do not access the external SPI flash device and instead return 0 immediately. Hardware interlocks ensure that the current transfer completes before mode transitions and control register updates take effect.</p>
</section>
</section>
<section id="id6">
<h4>2.3.2 Design Verification<a class="headerlink" href="#id6" title="Link to this heading"></a></h4>
<section id="id7">
<h5>Goals<a class="headerlink" href="#id7" title="Link to this heading"></a></h5>
<section id="id8">
<h6>DV<a class="headerlink" href="#id8" title="Link to this heading"></a></h6>
<p>Verify SPI IP features by running dynamic simulations with a SV/UVM based testbench</p>
</section>
</section>
<section id="id9">
<h5>Design features<a class="headerlink" href="#id9" title="Link to this heading"></a></h5>
<p>For detailed information on SPI design features, please see the <strong>SPI Technical Specification</strong>.</p>
</section>
<section id="id10">
<h5>Testbench architecture<a class="headerlink" href="#id10" title="Link to this heading"></a></h5>
<section id="id11">
<h6>Top level testbench<a class="headerlink" href="#id11" title="Link to this heading"></a></h6>
<p>Top level testbench is located at /trunk/hw/d2dv100_top/dv/dut_MEISHAV100_TOP_wrapper.sv. It instantiates the TOP DUT module /trunk/hw/d2dv100_top/rtl/top/MEISHAV100_TOP.sv. In addition, it instantiates the following interfaces, connects them to the DUT and sets their handle into <code class="docutils literal notranslate"><span class="pre">uvm_config_db</span></code>:</p>
<ul class="simple">
<li><p>Clock and reset interface</p></li>
<li><p>Tilelink host interface</p></li>
<li><p>SPI IOs</p></li>
</ul>
</section>
</section>
<section id="id12">
<h5>Global types &amp; methods<a class="headerlink" href="#id12" title="Link to this heading"></a></h5>
<p>All common types and methods defined at the package level can be found in <code class="docutils literal notranslate"><span class="pre">spi_env_pkg</span></code></p>
</section>
<section id="id13">
<h5>TL_agent<a class="headerlink" href="#id13" title="Link to this heading"></a></h5>
<p>SPI Device instantiates (already handled in CIP base env) tl_agent which provides the ability to drive and independently monitor random traffic via TL host interface into SPI Device.</p>
</section>
<section id="spi-agent">
<h5>SPI_agent<a class="headerlink" href="#spi-agent" title="Link to this heading"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">spi</span> <span class="pre">agent</span></code> is used to drive and monitor SPI items.</p>
</section>
</section>
<section id="id14">
<h4>2.3.2.1 Testplan<a class="headerlink" href="#id14" title="Link to this heading"></a></h4>
<p>This validation environment encompasses a substantial amount of supplementary code; however, the parent classes may introduce anomalies or superfluous functionalities. Consequently, it is permissible to directly alter the inherited parent class to the corresponding UVM base class, as necessitated</p>
<section id="id15">
<h5>2.3.2.1.1 Develop an agent<a class="headerlink" href="#id15" title="Link to this heading"></a></h5>
<p>Within this development environment, the SPI operates as a slave_agent driven by the CPU. Consequently, the SPI_agent comprises a single driver responsible for capturing signals emitted by the SPI ports during the testing process.</p>
<section id="spi-agent-cfg-sv">
<h6>spi_agent_cfg.sv<a class="headerlink" href="#spi-agent-cfg-sv" title="Link to this heading"></a></h6>
<p>This file defines properties such as the SPI polarity, phase, endianness, and declares an SPI interface for the monitor to collect data. The core function, <code class="docutils literal notranslate"><span class="pre">wait_sck_edge</span></code>, is pivotal as it determines the sampling timing based on the SPI’s polarity and phase.</p>
</section>
<section id="spi-agent-cov-sv">
<h6>spi_agent_cov.sv<a class="headerlink" href="#spi-agent-cov-sv" title="Link to this heading"></a></h6>
<p>The coverage-related file is currently empty.</p>
</section>
<section id="spi-agent-pkg-sv">
<h6>spi_agent_pkg.sv<a class="headerlink" href="#spi-agent-pkg-sv" title="Link to this heading"></a></h6>
<p>This file imports the libraries and modules required by the <code class="docutils literal notranslate"><span class="pre">SPI</span> <span class="pre">agent</span></code> and also defines various enumerated variables, such as csmode and transfer modes (single, dual, quad), enhancing convenience for usage.</p>
</section>
<section id="spi-agent-sv">
<h6>spi_agent.sv<a class="headerlink" href="#spi-agent-sv" title="Link to this heading"></a></h6>
<p>This defines an <code class="docutils literal notranslate"><span class="pre">spi_monitor</span></code> and <code class="docutils literal notranslate"><span class="pre">spi_config</span></code>, where the configured spi_if from config_db is passed to <code class="docutils literal notranslate"><span class="pre">spi_cfg</span></code>.<code class="docutils literal notranslate"><span class="pre">spi_if</span></code>. Additionally, spi_cfg is set in the database.</p>
</section>
<section id="spi-device-driver-sv">
<h6>spi_device_driver.sv<a class="headerlink" href="#spi-device-driver-sv" title="Link to this heading"></a></h6>
<p>The slave_spi driver currently remains unused.</p>
</section>
<section id="spi-driver-sv">
<h6>spi_driver.sv<a class="headerlink" href="#spi-driver-sv" title="Link to this heading"></a></h6>
<p>The base class for the spi_driver, from which both the master_spi and slave_spi drivers inherit. It defines two virtual tasks: reset and drive. Subclasses can extend it with additional tasks if neede</p>
</section>
<section id="spi-host-driver-sv">
<h6>spi_host_driver.sv<a class="headerlink" href="#spi-host-driver-sv" title="Link to this heading"></a></h6>
<p>The master_spi driver is currently inactive.</p>
</section>
<section id="spi-if-sv">
<h6>spi_if.sv<a class="headerlink" href="#spi-if-sv" title="Link to this heading"></a></h6>
<p>The SPI interface, designed to supply data to the monitor, encompasses the four fundamental SPI signals along with additional debug signals.</p>
</section>
<section id="spi-item-sv">
<h6>spi_item.sv<a class="headerlink" href="#spi-item-sv" title="Link to this heading"></a></h6>
<p>The data actually transmitted by the spi_sequence entails a queue for storing 8-bit data and the transfer type (either write or read).</p>
</section>
<section id="spi-monitor-sv">
<h6>spi_monitor.sv<a class="headerlink" href="#spi-monitor-sv" title="Link to this heading"></a></h6>
<p>The primary components of this file are the definition of two <code class="docutils literal notranslate"><span class="pre">spi_items</span></code> and two <code class="docutils literal notranslate"><span class="pre">uvm_analysis_ports</span></code>, which collect SPI transmission data and facilitate communication with the scoreboard. The core task, collect_trans, is responsible for gathering SPI transmission data. Given that the SPI chip select (CS) signal is active low, collection commences upon detecting a low state on CS. The process involves waiting for a rising edge (conditional on clock polarity and phase) before sampling the MISO signal for validity and storing it in a predefined array (considering endianness). Additionally, the spi_monitor incorporates rudimentary validation by initializing an incremental variable, exp, and comparing it to each collected 8-bit segment to verify data accuracy. Finally, the received data is transmitted to the host_analysis_port for extraction by the scoreboard.</p>
</section>
<section id="spi-sckmode-c-sv">
<h6>spi_sckmode_c.sv<a class="headerlink" href="#spi-sckmode-c-sv" title="Link to this heading"></a></h6>
<p>It is intended to randomize values within the sckmode, but given the current SPI configuration, it is not feasible to write to the corresponding registers via the bus. Consequently, this file remains inactive for the time being.</p>
</section>
<section id="spi-sequencer-sv">
<h6>spi_sequencer.sv<a class="headerlink" href="#spi-sequencer-sv" title="Link to this heading"></a></h6>
<p>The sequencer, designated for transmitting SPI data, currently remains vacant.</p>
</section>
<section id="spi-base-agent-core">
<h6>spi_base_agent.core<a class="headerlink" href="#spi-base-agent-core" title="Link to this heading"></a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">.core</span></code> file serves as a configuration management tool for projects in FuseSoC, allowing you to replicate existing configurations and modify their components as needed:</p>
<ul class="simple">
<li><p><strong>name</strong>: Set to “lowrisc:dv:XXX:0.1”, where XXX should be replaced with the corresponding name for your project. This name must align with any references to this configuration within other files.</p></li>
<li><p><strong>depend</strong>: Specify dependencies on other configuration files here, such as an environment dependency on an agent.</p></li>
<li><p><strong>files</strong>: This section lists all files included in the current configuration, encompassing all files from the referenced spi_agent. If file ‘a’ is included in file ‘b’, attribute {is_include_file: true} should be appended to file ‘a’.</p></li>
</ul>
<p>For additional details, consult the official FuseSoC documentation at:</p>
<p><a class="reference external" href="https://fusesoc.readthedocs.io/en/stable/user/build_system/index.html">https://fusesoc.readthedocs.io/en/stable/user/build_system/index.html</a>.</p>
</section>
</section>
<section id="id16">
<h5>2.3.2.1.2 Develop an env<a class="headerlink" href="#id16" title="Link to this heading"></a></h5>
<section id="spi-scoreboard-sv">
<h6>spi_scoreboard.sv<a class="headerlink" href="#spi-scoreboard-sv" title="Link to this heading"></a></h6>
<p>Four queues are defined to store the expected and actual write and read data. The expected data is sourced from the TL-agent, while the actual data is obtained from the SPI-agent. SPI data is retrieved via uvm_blocking_get_port, and a comparison is made between the expected and actual data. However, there are inherent issues with the current scoreboard, rendering it ineffective in the validation environment used.</p>
</section>
<section id="spi-env-sv">
<h6>spi_env.sv<a class="headerlink" href="#spi-env-sv" title="Link to this heading"></a></h6>
<p>The components include an spi_agent, an spi_agent_cfg, an spi_scoreboard, and a uvm_tlm_analysis_fifo which serves to connect the spi_scoreboard with the spi_monitor.</p>
</section>
<section id="spi-env-pkg-sv">
<h6>spi_env_pkg.sv<a class="headerlink" href="#spi-env-pkg-sv" title="Link to this heading"></a></h6>
<p>The necessary libraries and files for the spi_env are imported, and an enumeration variable, spi_host_intr_e, is defined (currently unused) to facilitate utilization</p>
</section>
<section id="spi-base-env-core">
<h6>spi_base_env.core<a class="headerlink" href="#spi-base-env-core" title="Link to this heading"></a></h6>
<p>The configuration file for the spi_env, designed to provide dependencies for the spi_test.</p>
</section>
</section>
<section id="develop-rals">
<h5>2.3.2.1.3 Develop rals<a class="headerlink" href="#develop-rals" title="Link to this heading"></a></h5>
<p>please translate this passage into more professional English by changing sentence structure,grammactical structure,words,etc</p>
</section>
<section id="develop-rtls">
<h5>2.3.2.1.4 Develop rtls<a class="headerlink" href="#develop-rtls" title="Link to this heading"></a></h5>
<p>To validate SPI read operations, an SPI-slave device was integrated into our SOC, enabling data transmission from the SOC’s SPI interface to the SPI-slave. The objective was to verify whether the SPI-slave could accurately relay the correct values back.</p>
<p>The RTL code for this purpose was sourced from a GitHub project (</p>
<p><a class="reference external" href="https://github.com/SherifMohamed2602/SPI_Interface">https://github.com/SherifMohamed2602/SPI_Interface</a></p>
<p>) authored by Sherif Mohamed. The project includes instructions for running tests, which were successfully validated through experimentation. According to the author’s implementation, the testing protocol involves sending 11-bit data segments. The first bit alters the SPI’s state (e.g., write data, read data, write address). The second and third bits indicate to the SPI-slave’s memory to store or transmit corresponding addresses or data. The remaining eight bits constitute the actual data (address or data) being written. This test case methodology was employed to conduct the SPI read validation.</p>
</section>
<section id="develop-seq-libs">
<h5>2.3.2.1.5 Develop seq_libs<a class="headerlink" href="#develop-seq-libs" title="Link to this heading"></a></h5>
<p>The base sequence for SPI, which is currently not utilized as the current environment employs the spi_item from the identical agent folder.</p>
</section>
<section id="develop-tests">
<h5>2.3.2.1.6 Develop tests<a class="headerlink" href="#develop-tests" title="Link to this heading"></a></h5>
<p>This test is adapted from the pre-existing tl-test within the reference environment.</p>
<section id="spi-macros-svh">
<h6>spi_macros.svh<a class="headerlink" href="#spi-macros-svh" title="Link to this heading"></a></h6>
<p>The base address and offset definitions for SPI registers facilitate efficient usage.</p>
</section>
<section id="spi-test-sv">
<h6>spi_test.sv<a class="headerlink" href="#spi-test-sv" title="Link to this heading"></a></h6>
<p>The test was written with reference to the tlul_test.sv, primarily modifying the code within the main_phase. Additional components include the definition of an spi_if within spi_base_test_cfg and an spi_env within spi_base_test.</p>
<p>Within the main_phase, data is sent to SPI registers via the tl-agent to configure them (as an alternative to the ral method). Data is then transmitted to the spi_txfifo, initiating automatic forwarding by the SPI. Accuracy of the mosi port’s output is verified through monitoring. Given that the txfifo can only transmit one byte of data at a time, test data ranging from 0x00 to 0xff is utilized to ensure comprehensive coverage.</p>
<p>The aforementioned process constitutes the write validation, which involves sending data to the spi_txfifo via the tl-agent and verifying its subsequent transmission. For read validation, an additional slave device is connected to the SOC. Notably, the exposed SD-related interfaces at the topmost level of the SOC correspond to the four standard SPI interfaces, facilitating the connection with the spi-slave.</p>
<p>For read validation, we refer to the original test cases within the spi-slave, which involve sending 11 bits per transaction with varying commands (occupying the first three bits). Due to our SPI’s limitation of transmitting one byte at a time, two data transmissions are required to complete a test. Specifically, data transmitted as A[7:0] and B[7:0] includes command signals in A[6:4], while the actual data consists of {A[3:0], B[7:4]}. Examination of the spi-slave’s RTL or TB files reveals support for four commands, with the “read data” operation requiring a third data transmission (of any value) to ensure complete data return via miso. Additionally, each test involves configuring the csmode register to hold, sending data twice to txfifo, and then disabling csmode. Between tests, an additional data transmission to txfifo is necessary to drive the spi-clk and reset certain values within the spi-slave for the next test.</p>
<p>The current write tests cover various polarity, phase, and endianness scenarios using test data from 0x00 to 0xff, all yielding correct results.</p>
</section>
</section>
</section>
<section id="hardware-interface">
<h4>2.3.3 Hardware Interface<a class="headerlink" href="#hardware-interface" title="Link to this heading"></a></h4>
<p>Within the U500 platform, only a single SPI (SPI0) interface is presently available, specifically designated for connecting to an SD card. The top-level module delineates the following correspondence between the SPI interface signals and the SD card signals:</p>
<p>| SPI Signal | Top-level SD Card Signal | I/O   |
|:————:|:————————-:|:——-:|
| SCK        | sdio_sdio_clk           | output |
| MOSI       | sdio_sdio_cmd           | output |
| MISO       | sdio_sdio_dat_0         | input  |
| CS         | sdio_sdio_dat_3         | output |</p>
<section id="detailed-explanation">
<h5>Detailed Explanation:<a class="headerlink" href="#detailed-explanation" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p><strong>SCK (Serial Clock)</strong>: The SPI clock signal, utilized for synchronizing data transmission, corresponds to the <code class="docutils literal notranslate"><span class="pre">sdio_sdio_clk</span></code> signal at the top-level module and is an output signal.</p></li>
<li><p><strong>MOSI (Master Out Slave In)</strong>: The signal for transmitting data from the master device to the slave device. In the context of SD card communication, this represents the master device (e.g., microprocessor) transmitting commands or data to the SD card. It maps to the <code class="docutils literal notranslate"><span class="pre">sdio_sdio_cmd</span></code> signal at the top-level module and is an output signal.</p></li>
<li><p><strong>MISO (Master In Slave Out)</strong>: The signal for transmitting data from the slave device to the master device. In the context of SD card communication, this represents the SD card returning data or responses to the master device. It maps to the <code class="docutils literal notranslate"><span class="pre">sdio_sdio_dat_0</span></code> signal at the top-level module and is an input signal.</p></li>
<li><p><strong>CS (Chip Select)</strong>: The signal used to select a specific slave device (SD card) for communication. It maps to the <code class="docutils literal notranslate"><span class="pre">sdio_sdio_dat_3</span></code> signal at the top-level module and is an output signal.</p></li>
</ul>
</section>
</section>
<section id="id17">
<h4>2.3.4 Registers<a class="headerlink" href="#id17" title="Link to this heading"></a></h4>
<section id="controller-memory-map-configuration">
<h5>Controller Memory Map Configuration<a class="headerlink" href="#controller-memory-map-configuration" title="Link to this heading"></a></h5>
<p>Offset | Name | Description
:———–: | :———–: | :———–:
0x00 | sckdiv | Serial clock divisor
0x04 | sckmode | Serial clock mode
0x10 | csid | Chip select ID
0x14 | csdef | Chip select default
0x18 | csmode | Chip select mode
0x28 | delay0 | Delay control 0
0x2c | delay1 | Delay control 1
0x38 | extradel |<br />0x3c | sampledel |<br />|   |<br />0x40 | fmt | Frame format
0x48 | txfifo | Tx FIFO data
0x4c | rxfifo | Rx FIFO data
0x50 | txmark | Tx FIFO watermark
0x54 | rxmark | Rx FIFO watermark
|   |<br />0x60 | fctrl | SPI flash interface control
0x64 | ffmt | SPI flash instruction format
|   |<br />0x70 | ie | SPI interrupt enable
0x74 | ip | SPI interrupt pending</p>
</section>
<section id="register-functionality-overview">
<h5>Register Functionality Overview<a class="headerlink" href="#register-functionality-overview" title="Link to this heading"></a></h5>
<section id="sckdiv">
<h6>SckDiv<a class="headerlink" href="#sckdiv" title="Link to this heading"></a></h6>
<p>The sckdiv register specifies the divisor used to generate the serial clock (SCK). The relationship between the input clock and SCK is defined by the following formula:
$$f_{sck}=\frac{f_{in}}{2(div+1)}$$</p>
<p>The input clock is the bus clock tlclk. The div field is reset to the value 0x3.</p>
<p>Alternatively, for a more detailed context:</p>
<p>The input clock is synchronized with the bus clock, denoted as tlclk. The div field within the sckdiv register, which governs the division factor for SCK generation, is initialized to a default value of 0x3 upon reset.</p>
<p>Bits | Fidle Name | Attr. | Rst. | Description
:———–: | :———–: | :———–: | :———–: | :———–:
[11:0] | div | RW | 0x3 | Divisor or serial clock
[31:12] | Reserved | RW | X | Reserved</p>
</section>
<section id="seral-clock-mode-register-sckmode">
<h6>Seral Clock Mode Register (sckmode)<a class="headerlink" href="#seral-clock-mode-register-sckmode" title="Link to this heading"></a></h6>
<p>The sckmode register dictates the polarity and phase attributes of the serial clock. Upon reset, the sckmode register is initialized to a default value of 0.</p>
<p>Bits | Fidle Name | Attr. | Rst. | Description
:–: | :–: | :–: | :–: | :–:
0 | pha | RW | 0x0 | Serial clock phase
1 | pol | RW | 0x0 | Serial clock polarity
[31:2] | Reserved | RW | X | Reserved</p>
<p>Serial Clock Polarity:
Value | Description |
:–: | :–: |
0 | The SCK signal remains at a logical level of 0 at idle|
1 |The SCK signal remains at a logical level of 1
at idle|</p>
<p>Serial Clock Phase：
Value | Description |
:–: | :–: |
0 | Data is sampled on the rising edge of SCK (leading edge) and shifted out on the falling edge of SCK (trailing edge) |
1 | Data is sampled on the falling edge of SCK (leading edge) and shifted out on the rising edge of SCK (trailing edge)|</p>
</section>
<section id="chip-select-id-register-csid">
<h6>Chip Select ID Register (csid)<a class="headerlink" href="#chip-select-id-register-csid" title="Link to this heading"></a></h6>
<p>The csid register encodes the index of the CS pin to be toggled by the hardware chip select control. The reset value for this register is 0.</p>
<p>Bits | Fidle Name | Attr. | Rst. | Description |
:–: | :–: | :–: | :–: | :–: |
[31:0] | csid | RW | 0x0000_0000 | Chip Select ID |</p>
</section>
<section id="chip-select-default-register-csdef">
<h6>Chip Select Default Register (csdef)<a class="headerlink" href="#chip-select-default-register-csdef" title="Link to this heading"></a></h6>
<p>The csdef register specifies the idle state (polarity) of the CS pins. For all implemented CS pins, the reset value is set to high.
Bits | Fidle Name | Attr. | Rst. | Description |
:–: | :–: | :–: | :–: | :–: |
[31:0] | csdef | RW | 0x0000_0001 | Chip Select Default Value |</p>
</section>
<section id="chip-select-mode-register-csmode">
<h6>Chip Select Mode Register (csmode)<a class="headerlink" href="#chip-select-mode-register-csmode" title="Link to this heading"></a></h6>
<p>The csmode register defines the behavior of the hardware chip select, as detailed in the table below. The reset value is 0 (AUTO). In HOLD mode, the CS pin remains deasserted under the following conditions:</p>
<ul class="simple">
<li><p>A different value is written to either csmode or csid.</p></li>
<li><p>A write to csdef results in a change of state for the selected pin.</p></li>
<li><p>Direct-mapped flash mode is enabled.</p></li>
</ul>
<p>Bits | Fidle Name | Attr. | Rst. | Description
:———–: | :———–: | :———–: | :———–: | :———–:
[1:0] | mode | RW | X | Chip Select Mode
[31:2] | Reserved | RW | X | Reserved</p>
<p>Value | Name | Description
:———–: | :———–: | :———–:
0 | AUTO | Toggle the CS signal at the beginning/end of each frame
2 | HOLD |Keep the CS signal asserted continuously after the initial frame
3 | OFF | Disable hardware control over the CS signal</p>
</section>
<section id="delay-control-registers-delay0-and-delay1">
<h6>Delay Control Registers (delay0 and delay1)<a class="headerlink" href="#delay-control-registers-delay0-and-delay1" title="Link to this heading"></a></h6>
<p>The delay0 and delay1 registers allow the insertion of arbitrary delays in terms of SCK cycles.</p>
<ul class="simple">
<li><p>The cssck field specifies the delay between setting CS and the first rising edge of SCK. An additional half-cycle delay is implied when sckmode.pha = 0. The reset value is 0x01.</p></li>
<li><p>The sckcs field specifies the delay between the last falling edge of SCK and the deassertion of CS. An additional half-cycle delay is implied when sckmode.pha = 1. The reset value is 0x01.</p></li>
<li><p>The intercs field specifies the minimum CS idle time between deassertion and reassertion. The reset value is 0x01.</p></li>
<li><p>The interxfr field specifies the delay between two consecutive frames without deasserting CS. This is applicable only when sckmode is in HOLD or OFF. The reset value is 0x00.</p></li>
</ul>
<p>delay0：
Bits | Fidle Name | Attr. | Rst. | Description |
:–: | :–: | :–: | :–: | :–: |
[7:0] | cssck | RW | 0x01 | CS to SCK Delay |
[15:8] | Reserved | RW | X | Reserved |
[23:16] | sckcs | RW | 0x01 | SCK to CS Delay |
[31:24] | Reserved | RW | X | Reserved |</p>
<p>delya1：
Bits | Fidle Name | Attr. | Rst. | Description |
:–: | :–: | :–: | :–: | :–: |
[7:0] | intercs | RW | 0x01 | Minimum CS inactive time |
[15:8] | Reserved | RW | X | Reserved |
[23:16] | interxfr | RW | 0x00 | Maximum interframe delay |
[31:24] | Reserved | RW | X | Reserved |</p>
</section>
<section id="frame-format-register-fmt">
<h6>Frame Format Register (fmt)<a class="headerlink" href="#frame-format-register-fmt" title="Link to this heading"></a></h6>
<p>The fmt register defines the frame format for transfers initiated via the Programmed I/O (FIFO) interface. The following table describes the proto, endian, and dir fields, which represent the protocol, endianness, and direction, respectively.</p>
<ul class="simple">
<li><p>The len field defines the number of bits per frame, with a permissible range from 0 to 8, inclusive.</p></li>
<li><p>For SPI0, the reset value of the fmt register is 0x0008 0008, which corresponds to proto = single, dir = Tx, endian = MSB, and len = 8.</p></li>
<li><p>For SPI1 and SPI2, the reset value of the fmt register is 0x0008 0000, which corresponds to proto = single, dir = Rx, endian = MSB, and len = 8.</p></li>
</ul>
<p>Bits | Fidle Name | Attr. | Rst. | Description
:———–: | :———–: | :———–: | :———–: | :———–:
[1:0] | proto | RW | 0x0 | SPI Protocol
2 | endian | RW | 0x0 | SPI endinanness
3 | dir | RW | 0x1 | SPI I/O Direction
[15:4] | Reserved | RW | X | Reserved
[19:16] | len | RW | 0x8 | Number of bits per frame
[31:20] | Reserved | RW | X | Reserved</p>
<p>SPI Protocol：
Value | Description | Data Pins |
:–: | :–: |:–: |
0 | Single | DQ0(MOSI), DQ1(MISO) |
1 | Dual | DQ0, DQ1|
2 | Quad | DQ0, DQ1, DQ2, DQ3 |</p>
<p>SPI Endianness：
Value | Description |
:–: | :–: |
0 | Transmit most-significant bit (MSB) first |
1 | Transmit least-significant bit (LSB) first |</p>
<p>SPI I/O Direction：</p>
<p>| Value | Description |
|:——-:|:————-:|
| 0     | Rx: In dual and quad protocols, the DQ pins are tri-stated. In the single protocol, the DQ0 pin is driven by the transmit data as usual. |
| 1     | Tx: Receive data is not stored in the receive FIFO. |</p>
</section>
<section id="id18">
<h6>Transmit Data Register (txdata)<a class="headerlink" href="#id18" title="Link to this heading"></a></h6>
<p>Writing to the txdata register loads the transmit FIFO with the value in the data field.</p>
<p>For the case where fmt.len &lt; 8, the value should be left-aligned when fmt.endian = MSB, and right-aligned when fmt.endian = LSB.</p>
<p>The full flag is set when the transmit FIFO is ready to accept a new entry; when set, writes to txdata are ignored. On read, the data field returns 0x00.</p>
<p>| Bits | Field Name | Attr. | Rst. | Description |
|:—–:|:———–:|:——:|:—–:|:————:|
| [7:0] | data | RW | 0x00 | Transmit Data |
| [30:8] | Reserved | RW | X | Reserved |
| 31 | full | RO | X | FIFO full flag |</p>
</section>
<section id="id19">
<h6>Receive Data Register (rxdata)<a class="headerlink" href="#id19" title="Link to this heading"></a></h6>
<p>Reading the rxdata register dequeues a frame from the receive FIFO.</p>
<p>For the case where fmt.len &lt; 8, the value should be left-aligned when fmt.endian = MSB, and right-aligned when fmt.endian = LSB.</p>
<p>The empty flag is set when the receive FIFO contains a new entry available for reading; when set, the data field does not contain a valid frame. Writes to rxdata are ignored.</p>
<p>| Bits | Field Name | Attr. | Rst. | Description |
|:—–:|:———–:|:——:|:—–:|:————:|
| [7:0] | data | RO | X | Received Data |
| [30:8] | Reserved | RO | X | Reserved |
| 31 | empty | RO | X | FIFO empty flag |</p>
</section>
<section id="transmit-watermark-register-txmark">
<h6>Transmit Watermark Register (txmark)<a class="headerlink" href="#transmit-watermark-register-txmark" title="Link to this heading"></a></h6>
<p>The txmark register specifies the threshold that triggers the Tx FIFO watermark interrupt.
For spi0, the reset value is 1; for spi1 and spi2, the reset value is 0.</p>
<p>| Bits | Field Name | Attr. | Rst. | Description |
|:—–:|:———–:|:——:|:—–:|:————:|
| [2:0] | txmark | RW | 0x1 | Transmit watermark |
| [31:3] | Reserved | RW | X | Reserved |</p>
</section>
<section id="receive-watermark-register-rxmark">
<h6>Receive Watermark Register (rxmark)<a class="headerlink" href="#receive-watermark-register-rxmark" title="Link to this heading"></a></h6>
<p>The rxmark specifies the threshold that triggers the Rx FIFO watermark interrupt. The reset value is 0.</p>
<p>| Bits | Field Name | Attr. | Rst. | Description |
|:—–:|:———–:|:——:|:—–:|:————:|
| [2:0] | rxmark | RW | 0x0 | Receive watermark |
| [31:3] | Reserved | RW | X | Reserved |</p>
</section>
<section id="spi-flash-interface-control-register-fctrl">
<h6>SPI Flash Interface Control Register (fctrl)<a class="headerlink" href="#spi-flash-interface-control-register-fctrl" title="Link to this heading"></a></h6>
<p>When the en bit of the fctrl register is set, the controller enters SPI Flash mode. Access to the memory-mapped region will cause the controller to automatically perform SPI Flash read sequences in hardware. The reset value is 0x1.</p>
<p>| Bits | Field Name | Attr. | Rst. | Description |
|:—–:|:———–:|:——:|:—–:|:————:|
| 0 | en | RW | 0x1 | SPI Flash Mode Select |
| [31:1] | Reserved | RW | X | Reserved |</p>
</section>
<section id="spi-flash-instruction-format-register-ffmt">
<h6>SPI Flash Instruction Format Register (ffmt)<a class="headerlink" href="#spi-flash-instruction-format-register-ffmt" title="Link to this heading"></a></h6>
<p>The ffmt register defines the format of the SPI Flash read instruction issued by the controller when accessing the memory-mapped region when the controller is in SPI Flash mode.</p>
<p>An instruction consists of a command byte, followed by a variable number of address bytes, dummy cycles (padding), and data bytes. The table below describes the function and reset value of each field.</p>
<p>| Bits | Field Name | Attr. | Rst. | Description |
|:—–:|:———–:|:——:|:—–:|:————:|
| 0 | cmd_en | RW | 0x1 | Enable sending of command |
| [3:1] | addr_len | RW | 0x3 | Number of address bytes (0 to 4) |
| [7:4] | pad_cnt | RW | 0x0 | Number of dummy cycles |
| [9:8] | cmd_proto | RW | 0x0 | Protocol for transmitting command |
| [11:10] | addr_proto | RW | 0x0 | Protocol for transmitting address and padding |
| [13:12] | data_proto | RW | 0x0 | Protocol for receiving data bytes |
| [15:14] | Reserved | RW | X | Reserved |
| [23:16] | cmd_code | RW | 0x03 | Value of command byte |
| [31:24] | pad_code | RW | 0x00 | First 8 bits to transmit during dummy cycles |</p>
</section>
<section id="spi-interrupt-registers-ie-and-ip">
<h6>SPI Interrupt Registers (ie and ip)<a class="headerlink" href="#spi-interrupt-registers-ie-and-ip" title="Link to this heading"></a></h6>
<p>The ie register controls which SPI interrupts are enabled, while ip is a read-only register indicating pending interrupt conditions. The reset value of ie is zero.</p>
<p>The txwm condition is triggered when the number of entries in the transmit FIFO is strictly less than the count specified by the txmark register. The pending bit is cleared when the number of enqueued entries is sufficiently large to exceed the watermark.</p>
<p>The rxwm condition is triggered when the number of entries in the receive FIFO is strictly greater than the count specified by the rxmark register. The pending bit is cleared when the number of dequeued entries is sufficiently small to fall below the watermark.</p>
<p>SPI Interrupt Enable Register (ie):
| Bits | Field Name | Attr. | Rst. | Description |
|:—–:|:———–:|:——:|:—–:|:————:|
| 0 | txwm | RW | 0x0 | Transmit watermark enable |
| 1 | rxwm | RW | 0x0 | Receive watermark enable |
| [31:2] | Reserved | RW | X | Reserved |</p>
<p>SPI Watermark Interrupt Pending Register (ip):
| Bits | Field Name | Attr. | Rst. | Description |
|:—–:|:———–:|:——:|:—–:|:————:|
| 0 | txwm | RO | 0x0 | Transmit watermark pending |
| 1 | rxwm | RO | 0x0 | Receive watermark pending |
| [31:2] | Reserved | RW | X | Reserved |</p>
</section>
</section>
</section>
<section id="id20">
<h4>2.3.5  Checklist<a class="headerlink" href="#id20" title="Link to this heading"></a></h4>
</section>
</section>
<section id="jtag">
<h3>2.4 JTAG<a class="headerlink" href="#jtag" title="Link to this heading"></a></h3>
<section id="jtag-technical-specification">
<h4>2.4.1 JTAG Technical Specification<a class="headerlink" href="#jtag-technical-specification" title="Link to this heading"></a></h4>
<p><img alt="alt text" src="../_images/image-22.png" /></p>
</section>
<section id="id21">
<h4>Description<a class="headerlink" href="#id21" title="Link to this heading"></a></h4>
<p>JTAG (Joint Test Action Group), an international standard testing protocol conforming to IEEE 1149.1, is primarily used for internal chip testing. Many advanced devices, such as DSPs and FPGAs, support the JTAG protocol. The standard JTAG interface comprises four lines: TMS, TCK, TDI, and TDO, representing Mode Select, Clock, Data Input, and Data Output, respectively.</p>
<p>Initially designed for chip testing, JTAG operates by defining a TAP (Test Access Port) within the device, allowing internal nodes to be tested using dedicated JTAG tools. JTAG’s unique capability enables multiple devices to be daisy-chained via the JTAG interface, forming a JTAG chain that facilitates individual device testing. Beyond testing, the JTAG interface is also commonly utilized for In-System Programming (ISP), enabling programming of components like FLASH memory.</p>
<p>JTAG’s in-system programming approach revolutionizes traditional production flows, where chips were pre-programmed before being soldered onto boards. This method simplifies the process by allowing devices to be secured onto the board first, followed by JTAG programming, significantly accelerating project timelines. The JTAG interface can program all components within a PSD (Programmable System Device) chip.</p>
</section>
<section id="id22">
<h4>2.4.2 Theory of Operation<a class="headerlink" href="#id22" title="Link to this heading"></a></h4>
<section id="module-structure">
<h5>2.4.2.1 Module Structure<a class="headerlink" href="#module-structure" title="Link to this heading"></a></h5>
<section id="meishav100-dm-and-jtag-connection-diagram">
<h6>MEISHAV100 DM and JTAG Connection Diagram<a class="headerlink" href="#meishav100-dm-and-jtag-connection-diagram" title="Link to this heading"></a></h6>
<p>The DM and JTAG connection diagram for MEISHAV100 is as follows:</p>
<div align=center><img src="photo/image-17.png" width="400"  alt="2">    <div>
<div align=left><div>   <p>Since the project is generated by Chisel, the modules used are in accordance with the specifications of SiFive and UC Berkeley.</p>
<p>Here, the TLDebugModule uses the Debug design from Rocket-Chip. The file location is:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>:/src/main/scala/device/debug
<span class="p">|</span>-<span class="w"> </span>Debug.scala
</pre></div>
</div>
<p>The DebugTransportModuleJTAG uses the design from the following location:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>:/src/main/scala/device/debug
<span class="p">|</span>-<span class="w"> </span>DebugTransport.scala
:/src/main/scala/JtagTap.scala
<span class="p">|</span>-<span class="w"> </span>JtagTap.scala
<span class="p">|</span>-<span class="w"> </span>JtagShifter.scala
<span class="p">|</span>-<span class="w"> </span>JtagStateMachine.scala
</pre></div>
</div>
</section>
<section id="top-module-tldebugmodule-slave">
<h6>2.4.2.1.1 top_module: TLDebugModule (slave)<a class="headerlink" href="#top-module-tldebugmodule-slave" title="Link to this heading"></a></h6>
<ul class="simple">
<li><p><strong>TLDebugModuleOuterAsync</strong></p>
<ul>
<li><p>DMIToTL</p></li>
<li><p>TLXbar_7</p></li>
<li><p>TLDebugModuleOuter</p></li>
<li><p>IntSyncCrossingSource</p></li>
<li><p>TLAsyncCrossingSource</p></li>
<li><p>AsyncQueueSource_1</p></li>
</ul>
</li>
<li><p><strong>TLDebugModuleInnerAsync</strong></p>
<ul>
<li><p>TLDebugModuleInner</p></li>
<li><p>TLAsyncCrossingSink</p></li>
<li><p>AsyncQueueSink_1</p></li>
<li><p>AsyncQueueSource_2</p></li>
<li><p>AsyncQueueSink_2</p></li>
<li><p>ResetCatchAndSync_d3</p></li>
</ul>
</li>
</ul>
</section>
<section id="top-module-debugtransportmodulejtag-master-s-interface">
<h6>2.4.2.1.2 top_module: DebugTransportModuleJTAG (master’s interface)<a class="headerlink" href="#top-module-debugtransportmodulejtag-master-s-interface" title="Link to this heading"></a></h6>
<ul class="simple">
<li><p>CaptureUpdateChain (as dtmInfoChain)</p></li>
<li><p>CaptureUpdateChain_1 (as dtmAccessChain)</p></li>
<li><p>CaptureChain (as idcodeChain)</p></li>
<li><p>JtagTapController</p>
<ul>
<li><p>JtagStateMachine</p></li>
<li><p>CaptureUpdateChain_2 (as irChain)</p></li>
</ul>
</li>
<li><p>JtagBypassChain</p></li>
</ul>
<p>Overall, only DR Bypass and IR are implemented, which is not related to verification.</p>
<p>For reference, the Rocket-Chip project can be found at: <a class="reference external" href="https://github.com/chipsalliance/rocket-chip/tree/master">https://github.com/chipsalliance/rocket-chip/tree/master</a>.</p>
</section>
</section>
<section id="jtag-tapc-state-machine">
<h5>2.4.2.2 JTAG TAPC State Machine<a class="headerlink" href="#jtag-tapc-state-machine" title="Link to this heading"></a></h5>
<p>The JTAG controller incorporates the standard TAPC state machine as depicted in Figure 1, with the state machine handling clocking via TCK.</p>
<div align=center><img src="photo/image-18.png" width=600  alt="2">  <div>
<div align=left><div>  </section>
<section id="resetting-jtag-logic">
<h5>2.4.2.3  Resetting JTAG Logic<a class="headerlink" href="#resetting-jtag-logic" title="Link to this heading"></a></h5>
<p>Asynchronous reset of the JTAG logic must be achieved by asserting the power-on-reset signal, which drives an internal jtag_reset signal.</p>
<p>Asserting jtag_reset will reset both the JTAG DTM and the debug module test logic. Since certain debug logic requires a synchronous reset, the jtag_reset signal is internally synchronized within the FU540-C000.</p>
<p>During operation, the JTAG DTM logic can also be reset without involving jtag_reset by asserting jtag_TMS while issuing five jtag_TCK clock ticks. This operation only resets the JTAG DTM, not the debug module.</p>
</section>
<section id="jtag-clocking">
<h5>2.4.2.4 JTAG Clocking<a class="headerlink" href="#jtag-clocking" title="Link to this heading"></a></h5>
<p>The JTAG logic always operates within its own clock domain, which is clocked by jtag_TCK. The JTAG logic is fully static and has no minimum clock frequency requirement. The maximum jtag_TCK frequency is part-specific.</p>
</section>
<section id="jtag-standard-instructions">
<h5>2.4.2.5 JTAG Standard Instructions<a class="headerlink" href="#jtag-standard-instructions" title="Link to this heading"></a></h5>
<p>The JTAG DTM implements the BYPASS and IDCODE instructions.
The IDCODE for the FU540-C000 is set to 0x20000913.</p>
</section>
<section id="jtag-debug-commands">
<h5>2.4.2.6 JTAG Debug Commands<a class="headerlink" href="#jtag-debug-commands" title="Link to this heading"></a></h5>
<p>The JTAG DEBUG instruction accesses the SiFive debug module by connecting the debug scan register between jtag_TDI and jtag_TDO.</p>
</section>
<section id="overview-of-states">
<h5>2.4.2.7 Overview of States<a class="headerlink" href="#overview-of-states" title="Link to this heading"></a></h5>
<p>A conceptual view is provided of the states a hart transitions through during run/halt debugging, which are influenced by various fields in dmcontrol, abstractcs, abstractauto, and command.</p>
<div align=center><img src="photo/image-19.png" width="600"  alt="2">    <div>
<div align=left><div>   </section>
</section>
<section id="jtag-design-verification">
<h4>2.4.3 JTAG Design Verification<a class="headerlink" href="#jtag-design-verification" title="Link to this heading"></a></h4>
<section id="id23">
<h5>Goals<a class="headerlink" href="#id23" title="Link to this heading"></a></h5>
<section id="id24">
<h6>DV<a class="headerlink" href="#id24" title="Link to this heading"></a></h6>
<p>Verify JTAG IP features by running dynamic simulations with a SV/UVM based testbench</p>
</section>
</section>
<section id="id25">
<h5>Design features<a class="headerlink" href="#id25" title="Link to this heading"></a></h5>
<p>For detailed information on JTAG design features, please see the <strong>JTAG Technical Specification</strong>.</p>
</section>
<section id="id26">
<h5>Testbench architecture<a class="headerlink" href="#id26" title="Link to this heading"></a></h5>
<section id="id27">
<h6>Top level testbench<a class="headerlink" href="#id27" title="Link to this heading"></a></h6>
<p>Top level testbench is located at /trunk/hw/d2dv100_top/dv/dut_MEISHAV100_TOP_wrapper.sv. It instantiates the TOP DUT module /trunk/hw/d2dv100_top/rtl/top/MEISHAV100_TOP.sv. In addition, it instantiates the following interfaces, connects them to the DUT and sets their handle into <code class="docutils literal notranslate"><span class="pre">uvm_config_db</span></code>:</p>
<ul class="simple">
<li><p>Clock and reset interface</p></li>
<li><p>Tilelink host interface</p></li>
<li><p>JTAG IOs</p></li>
</ul>
</section>
</section>
<section id="id28">
<h5>Global types &amp; methods<a class="headerlink" href="#id28" title="Link to this heading"></a></h5>
<p>All common types and methods defined at the package level can be found in <code class="docutils literal notranslate"><span class="pre">JTAG_env_pkg</span></code></p>
</section>
<section id="id29">
<h5>TL_agent<a class="headerlink" href="#id29" title="Link to this heading"></a></h5>
<p>JTAG Device instantiates <code class="docutils literal notranslate"><span class="pre">tl_agent</span></code> which provides the ability to drive and independently monitor random traffic via TL host interface into JTAG Device.</p>
</section>
<section id="jtag-agent">
<h5>JTAG_agent<a class="headerlink" href="#jtag-agent" title="Link to this heading"></a></h5>
<p><code class="docutils literal notranslate"><span class="pre">JTAG</span> <span class="pre">agent</span></code> is used to drive and monitor JTAG items.</p>
</section>
<section id="id30">
<h5>2.4.3.1 Testplan<a class="headerlink" href="#id30" title="Link to this heading"></a></h5>
<section id="allocate-resources-initialize-member-variables">
<h6>2.4.3.1.1 Allocate resources, initialize member variables.<a class="headerlink" href="#allocate-resources-initialize-member-variables" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">uvm_component</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span>
<span class="w">        </span><span class="k">super</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span>
<span class="w">        </span><span class="n">set_type_override_by_type</span><span class="p">(</span><span class="n">dv_lib_pkg</span><span class="o">::</span><span class="n">dv_base_env_cfg</span><span class="p">#(</span><span class="n">tlul_base_env_pkg</span><span class="o">::</span><span class="n">tlul_base_reg_block</span><span class="p">)</span><span class="o">::</span><span class="n">get_type</span><span class="p">(),</span><span class="w"> </span><span class="no">`tc_name_cfg</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
<span class="w">        </span><span class="n">set_type_override_by_type</span><span class="p">(</span><span class="n">tlul_base_env_cfg</span><span class="o">::</span><span class="n">get_type</span><span class="p">(),</span><span class="w"> </span><span class="no">`tc_name_cfg</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
<span class="w">        </span><span class="n">cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`tc_name_cfg</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;test_cfg&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="n">jtag_base_env</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jtag_env_pkg</span><span class="o">::</span><span class="n">jtag_env</span><span class="o">::</span><span class="n">type_id</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">&quot;jtag_base_env&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="n">dr_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dr_seq&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">dmstatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dmstatus&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">dtmcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dtmcs&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">dmcontrol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dmcontrol&quot;</span><span class="p">);</span><span class="w">        </span>
<span class="w">        </span><span class="n">dmabstractcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="s">&quot;dmabstractcs&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="c1">////uart_base_env = uart_env::type_id::create(&quot;uart_base_env&quot;, this);</span>
<span class="w">        </span><span class="c1">////set_type_override_by_type(dv_base_scoreboard#(dv_base_reg_pkg::dv_base_reg_block,dv_base_env_cfg,dv_base_env_cov)::get_type(), spi_scoreboard::get_type());</span>
<span class="w">    </span><span class="k">endfunction</span><span class="w"> </span><span class="c1">//new()</span>
</pre></div>
</div>
</section>
<section id="read-id-code-reading-idcode-instruction">
<h6>2.4.3.1.2 read_id_code(Reading IDCODE instruction)<a class="headerlink" href="#read-id-code-reading-idcode-instruction" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_id_code</span><span class="p">();</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_ir</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DTM_IDCODE</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mh">32&#39;h0000_0000</span><span class="p">});</span><span class="w">  </span><span class="c1">// randomize value  IDCODE WIDTH is 32</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="mh">32&#39;h20000913</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_error</span><span class="p">(</span><span class="s">&quot;read_id_code&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;%h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">))</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="read-dtmcs-reading-the-dtm-status">
<h6>2.4.3.1.3 read_dtmcs(Reading the DTM status)<a class="headerlink" href="#read-dtmcs-reading-the-dtm-status" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_dtmcs</span><span class="p">();</span>
<span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">abits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`DTM_ABITS</span><span class="p">;</span>
<span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">idle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`DTM_IDLE_DELAY_CYCLE</span><span class="p">;</span>
<span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_ir</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DTM_DTMCS</span><span class="p">);</span>
<span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mh">32&#39;h0000_0000</span><span class="p">});</span><span class="w">  </span><span class="c1">// randomize value  IDCODE WIDTH is 32</span>
<span class="k">if</span><span class="p">({</span><span class="mh">14&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">idle</span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mb">2&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">abits</span><span class="p">[</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mb">4&#39;b1</span><span class="p">}</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="no">`uvm_error</span><span class="p">(</span><span class="s">&quot;read_dtmcs&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;%h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">))</span>
<span class="k">end</span>
<span class="c1">// data_array = new[4];</span>
<span class="c1">// for ( int i = 0; i &lt; 4; i++ ) begin</span>
<span class="c1">//     data_array[i] = this.dr_seq.rsp.dout[(i*8)+:8];</span>
<span class="c1">// end</span>
<span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">unpack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;read_dtmcs:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>
<span class="c1">// this.dtmcs.dmihardreset = this.dr_seq.rsp.dout[17];</span>
<span class="c1">// this.dtmcs.dmireset = this.dr_seq.rsp.dout[16];</span>
<span class="c1">// this.dtmcs.idle = this.dr_seq.rsp.dout[14:12];</span>
<span class="c1">// this.dtmcs.dmistat = this.dr_seq.rsp.dout[11:10];</span>
<span class="c1">// this.dtmcs.abits = this.dr_seq.rsp.dout[9:4];</span>
<span class="c1">// this.dtmcs.version = this.dr_seq.rsp.dout[3:0];</span>
<span class="k">endtask</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">this.dtmcs.unpack_ints(data_array);</span></code> is responsible for unpacking the integer values from the <code class="docutils literal notranslate"><span class="pre">data_array</span></code> and assigning them to the respective member variables of the <code class="docutils literal notranslate"><span class="pre">dtmcs</span></code> object.</p>
</section>
<section id="read-dmcontrol-reading-debug-module-control">
<h6>2.4.3.1.4 read_dmcontrol(Reading Debug Module Control)<a class="headerlink" href="#read-dmcontrol-reading-debug-module-control" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_dmcontrol</span><span class="p">();</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">dmi_read</span><span class="p">(</span><span class="n">DM_DMCONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">unpack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;read_dmcontrol:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="dmi-read-reading-data-via-debug-module-interface">
<h6>2.4.3.1.5  dmi_read(Reading data via Debug Module Interface)<a class="headerlink" href="#dmi-read-reading-data-via-debug-module-interface" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">dmi_read</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="k">output</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">check_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 执行DMI读操作</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_ir</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DTM_DMI</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// read dr more time , wait data flush complete</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="no">`DTM_ABITS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">address</span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">32&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h1</span><span class="p">});</span>
<span class="w">    </span><span class="c1">//data[31:0] = this.dr_seq.rsp.dout[33:2];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="no">`DTM_ABITS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">address</span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">32&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h1</span><span class="p">});</span>
<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">dout</span><span class="p">[</span><span class="mi">33</span><span class="o">:</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// this.dr_seq.send_dr(this.jtag_base_env.m_jtag_agent.sequencer, `DTM_ABITS + 34, {address[`DTM_ABITS-1:0], 32&#39;h0, 2&#39;h1});</span>
<span class="w">    </span><span class="c1">// data[31:0] = this.dr_seq.rsp.dout[33:2];</span>
<span class="w">    </span><span class="c1">// 等待读操作完成并检查状态</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">check_timeout</span><span class="o">++</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="no">`uvm_fatal</span><span class="p">(</span><span class="s">&quot;dmi_read&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;timeout,address &#39;h%0h, data &#39;h%0h: dmistat %h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="p">))</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">read_dtmcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">2&#39;h3</span><span class="p">);</span><span class="w"> </span><span class="c1">// repeat try once</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_error</span><span class="p">(</span><span class="s">&quot;dmi_read&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;address &#39;h%0h, data &#39;h%0h: dmistat %h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="p">))</span>
<span class="w">        </span><span class="c1">// clear status</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmireset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b1</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">write_dtmcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_info</span><span class="p">(</span><span class="s">&quot;dmi_read&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;address &#39;h%0h, data &#39;h%0h: success&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="read-dmstatus-reading-data-via-debug-module-interface">
<h6>2.4.3.1.6 read_dmstatus(Reading data via Debug Module Interface)<a class="headerlink" href="#read-dmstatus-reading-data-via-debug-module-interface" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_dmstatus</span><span class="p">();</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">dmi_read</span><span class="p">(</span><span class="n">DM_DMSTATUS</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// data_array = new[4];</span>
<span class="w">    </span><span class="c1">// for ( int i = 0; i &lt; 4; i++ ) begin</span>
<span class="w">    </span><span class="c1">//     data_array[i] = data[(i*8)+:8];</span>
<span class="w">    </span><span class="c1">// end</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dmstatus</span><span class="p">.</span><span class="n">unpack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;read_dmstatus:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dmstatus</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="write-dmcontrol-writing-debug-module-control">
<h6>2.4.3.1.7 write_dmcontrol（Writing Debug Module Control）<a class="headerlink" href="#write-dmcontrol-writing-debug-module-control" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">write_dmcontrol</span><span class="p">();</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">pack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="w">    </span><span class="n">dmi_write</span><span class="p">(</span><span class="n">DM_DMCONTROL</span><span class="p">,</span><span class="w"> </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;write_dmcontrol:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="dmi-write-writing-data-via-debug-module-interface">
<h6>2.4.3.1.8 dmi_write(Writing data via Debug Module Interface)<a class="headerlink" href="#dmi-write-writing-data-via-debug-module-interface" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">dmi_write</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="k">input</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">check_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 执行DMI写操作</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_ir</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">DTM_DMI</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dr_seq</span><span class="p">.</span><span class="n">send_dr</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">jtag_base_env</span><span class="p">.</span><span class="n">m_jtag_agent</span><span class="p">.</span><span class="n">sequencer</span><span class="p">,</span><span class="w"> </span><span class="no">`DTM_ABITS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">address</span><span class="p">[</span><span class="no">`DTM_ABITS</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">2&#39;h2</span><span class="p">});</span>

<span class="w">    </span><span class="c1">// 等待写操作完成并检查状态</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">check_timeout</span><span class="o">++</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="no">`uvm_fatal</span><span class="p">(</span><span class="s">&quot;dmi_write&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;timeout,address &#39;h%0h, data &#39;h%0h: dmistat %h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="p">))</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">read_dtmcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">2&#39;h3</span><span class="p">);</span><span class="w"> </span><span class="c1">// repeat try once</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_error</span><span class="p">(</span><span class="s">&quot;dmi_write&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;address &#39;h%0h, data &#39;h%0h: dmistat %h not expect&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dtmcs</span><span class="p">.</span><span class="n">dmistat</span><span class="p">))</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">write_dtmcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="no">`uvm_info</span><span class="p">(</span><span class="s">&quot;dmi_write&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;address &#39;h%0h, data &#39;h%0h: success&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="read-dmabstractcs-reading-abstract-control-and-status">
<h6>2.4.3.1.9 read_dmabstractcs(Reading Abstract Control and Status)<a class="headerlink" href="#read-dmabstractcs-reading-abstract-control-and-status" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">read_dmabstractcs</span><span class="p">();</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">dmi_read</span><span class="p">(</span><span class="n">DM_ABS_CS</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">dmabstractcs</span><span class="p">.</span><span class="n">unpack_ints</span><span class="p">(</span><span class="n">data_array</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;dmabstractcs:</span><span class="se">\n</span><span class="s">%0s&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">dmabstractcs</span><span class="p">.</span><span class="n">sprint</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="execute-progbuf-setting-buffer-area-progbufsize">
<h6>2.4.3.1.10  execute_progbuf(Setting buffer area progbufsize)<a class="headerlink" href="#execute-progbuf-setting-buffer-area-progbufsize" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">execute_progbuf</span><span class="p">();</span>

<span class="w">    </span><span class="n">write_dmabstract_cmd</span><span class="p">(</span><span class="mh">8&#39;h1</span><span class="p">,</span><span class="w"> </span><span class="mh">24&#39;h0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;execute_progbuf&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="access-hart-reg">
<h6>2.4.3.1.11 access_hart_reg<a class="headerlink" href="#access-hart-reg" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">access_hart_reg</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">aarsize</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">aarpostincrement</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">postexec</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">transfer</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">regno</span><span class="p">);</span>

<span class="w">    </span><span class="n">write_dmabstract_cmd</span><span class="p">(</span><span class="mh">8&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">aarsize</span><span class="p">,</span><span class="w"> </span><span class="n">aarpostincrement</span><span class="p">,</span><span class="w"> </span><span class="n">postexec</span><span class="p">,</span><span class="w"> </span><span class="n">transfer</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="n">regno</span><span class="p">});</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;access_hart_reg: &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">aarsize</span><span class="p">,</span><span class="w"> </span><span class="n">aarpostincrement</span><span class="p">,</span><span class="w"> </span><span class="n">postexec</span><span class="p">,</span><span class="w"> </span><span class="n">transfer</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="n">regno</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="access-hart-mem">
<h6>2.4.3.1.12 access_hart_mem<a class="headerlink" href="#access-hart-mem" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">access_hart_mem</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="n">aamvirtual</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">aamsize</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">aampostincrement</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">target_specific</span><span class="p">);</span>

<span class="w">    </span><span class="n">write_dmabstract_cmd</span><span class="p">(</span><span class="mh">8&#39;h2</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">aamvirtual</span><span class="p">,</span><span class="w"> </span><span class="n">aamsize</span><span class="p">,</span><span class="w"> </span><span class="n">aampostincrement</span><span class="p">,</span><span class="w"> </span><span class="mb">2&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="n">target_specific</span><span class="p">,</span><span class="w"> </span><span class="mh">14&#39;h0</span><span class="p">});</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;access_hart_mem: &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h, &#39;h%0h&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">aamvirtual</span><span class="p">,</span><span class="w"> </span><span class="n">aamsize</span><span class="p">,</span><span class="w"> </span><span class="n">aampostincrement</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="n">target_specific</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="write-dmabstract-cmd">
<h6>2.4.3.1.13 write_dmabstract_cmd<a class="headerlink" href="#write-dmabstract-cmd" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">write_dmabstract_cmd</span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">cmdtype</span><span class="p">,</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">control</span><span class="p">);</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">automatic</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">data_array</span><span class="p">[];</span>
<span class="w">    </span><span class="n">data_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">cmdtype</span><span class="p">,</span><span class="w"> </span><span class="n">control</span><span class="p">};</span>
<span class="w">    </span><span class="n">dmi_write</span><span class="p">(</span><span class="n">DM_ABS_CMD</span><span class="p">,</span><span class="w"> </span><span class="n">data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="p">$</span><span class="n">sformatf</span><span class="p">(</span><span class="s">&quot;write_dmabstract_cmd: &#39;h%0h, &#39;h%0h&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cmdtype</span><span class="p">,</span><span class="w"> </span><span class="n">control</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_LOW</span><span class="p">)</span>

<span class="k">endtask</span>
</pre></div>
</div>
</section>
<section id="the-program-is-running">
<h6>2.4.3.1.14 The program is running.<a class="headerlink" href="#the-program-is-running" title="Link to this heading"></a></h6>
<div class="highlight-systemverilog notranslate"><div class="highlight"><pre><span></span><span class="k">begin</span><span class="w"> </span>
<span class="w">        </span><span class="n">read_id_code</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//#5000ns;</span>
<span class="w">        </span><span class="n">read_dtmcs</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//#5000ns;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="k">begin</span>
<span class="w">        </span><span class="n">read_dmcontrol</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//#5000ns;</span>
<span class="w">        </span><span class="n">read_dmstatus</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//#5000ns;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="k">begin</span>
<span class="w">        </span><span class="c1">// halt all cpu</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">haltreq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b1</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">hasel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">hartsello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">10&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">dmcontrol</span><span class="p">.</span><span class="n">dmactive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b1</span><span class="p">;</span><span class="w"> </span><span class="c1">// must be 1 for debug</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">write_dmcontrol</span><span class="p">();</span>
<span class="w">        </span><span class="p">#</span><span class="mi">5</span><span class="n">us</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">write_dmcontrol</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="k">begin</span>
<span class="w">        </span><span class="c1">// test abstract cmd</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">read_dmabstractcs</span><span class="p">();</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">access_hart_reg</span><span class="p">(</span><span class="mi">2</span><span class="cm">/*aarsize*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*aarpostincrement*/</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="cm">/*postexec*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*transfer*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*write*/</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="cm">/*regno*/</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">access_hart_mem</span><span class="p">(</span><span class="mi">0</span><span class="cm">/*aamvirtual*/</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="cm">/*aamsize*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*aampostincrement*/</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="cm">/*write*/</span><span class="p">,</span><span class="w"> </span><span class="mb">2&#39;b0</span><span class="cm">/*target_specific*/</span><span class="p">);</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">execute_progbuf</span><span class="p">();</span>
<span class="w">    </span><span class="k">end</span>
</pre></div>
</div>
</section>
</section>
<section id="fpga-verification-via-openocd">
<h5>FPGA Verification Via OpenOCD<a class="headerlink" href="#fpga-verification-via-openocd" title="Link to this heading"></a></h5>
<p>Users interact with the debugging host (such as a laptop) running a debugger (such as GDB). The debugger communicates with the debug adapter (for example, <strong>OpenOCD</strong>, which may include a hardware driver) to interface with the debug transport hardware (such as an Olimex USB-JTAG adapter). The debug transport hardware connects the debug host to the platform’s Debug Transport Module (DTM). The DTM uses the Debug Module Interface (DMI) to provide access to one or more Debug Modules (DM).</p>
<p>To stop one or more harts, the debugger selects them, sets haltreq, and then waits for the allhalted indication that the harts have stopped. It can then clear haltreq to 0, or keep it high to catch harts that reset while paused.</p>
<p>The platform is a single integrated circuit composed of one or more components. Some components may be RISC-V cores, while others may have different functions. Typically, they will all be connected to a single system bus. A single RISC-V core contains one or more hardware threads, called harts.</p>
</section>
</section>
<section id="id31">
<h4>2.4.4 Hardware Interfaces<a class="headerlink" href="#id31" title="Link to this heading"></a></h4>
<p>The mapping of top-level JTAG signals in the U500 module is represented in the following table:</p>
<p>JTAG Singal | Top JTAG Singal | I/O
:———–: | :———–: | :———–:
TCK | jtag_jtag_TCK | input
TMS | jtag_jtag_TMS | input
TDI | jtag_jtag_TDI | input
TDO | jtag_jtag_TDO | output</p>
</section>
<section id="id32">
<h4>2.4.5 Registers<a class="headerlink" href="#id32" title="Link to this heading"></a></h4>
<section id="debug-module-debug-bus-registers">
<h5>2.4.5.1 Debug Module Debug Bus Registers<a class="headerlink" href="#debug-module-debug-bus-registers" title="Link to this heading"></a></h5>
<p>Address | Name
:———–: | :———–:
0x04 |   Abstract Data 0 (data0)
0x0f|Abstract Data 11 (data11)
0x10|Debug Module Control (dmcontrol)
0x11|Debug Module Status (dmstatus)
0x12|Hart Info (hartinfo)
0x13|Halt Summary 1 (haltsum1)
0x14|Hart Array Window Select (hawindowsel)
0x15|Hart Array Window (hawindow)
0x16|Abstract Control and Status (abstractcs)
0x17|Abstract Command (command)
0x18|Abstract Command Autoexec (abstractauto)
0x19|Configuration String Pointer 0 (confstrptr0)
0x1a|Configuration String Pointer 1 (confstrptr1)
0x1b|Configuration String Pointer 2 (confstrptr2)
0x1c|Configuration String Pointer 3 (confstrptr3)
0x1d|Next Debug Module (nextdm)
0x20|Program Buffer 0 (progbuf0)
0x2f|Program Buffer 15 (progbuf15)
0x30|Authentication Data (authdata)
0x34|Halt Summary 2 (haltsum2)
0x35|Halt Summary 3 (haltsum3)
0x37|System Bus Address 127:96 (sbaddress3)
0x38|System Bus Access Control and Status (sbcs)
0x39|System Bus Address 31:0 (sbaddress0)
0x3a|System Bus Address 63:32 (sbaddress1)
0x3b|System Bus Address 95:64 (sbaddress2)
0x3c|System Bus Data 31:0 (sbdata0)
0x3d|System Bus Data 63:32 (sbdata1)
0x3e|System Bus Data 95:64 (sbdata2)
0x3f|System Bus Data 127:96 (sbdata3)
0x40 |Halt Summary 0 (haltsum0) |</p>
</section>
<section id="dtm-jtag-dtm-registers">
<h5>2.4.5.2 DTM JTAG DTM Registers<a class="headerlink" href="#dtm-jtag-dtm-registers" title="Link to this heading"></a></h5>
<p>Address | Name | Descripition
:———–: | :———–: | :———–:
0x00 | BYPASS | JTAG recommends this encoding
0x01 | IDCODE | JTAG recommends this encoding
0x10 | DTM Control and Status (dtmcs) | For Debugging
0x11 | Debug Module Interface Access (dmi) | For Debugging
0x12 | Reserved (BYPASS) | Reserved for future RISC-V debugging
0x13 | Reserved (BYPASS) | Reserved for future RISC-V debugging
0x14 | Reserved (BYPASS) | Reserved for future RISC-V debugging
0x15 | Reserved (BYPASS) | Reserved for future RISC-V debugging
0x16 | Reserved (BYPASS) | Reserved for future RISC-V debugging
0x17 | Reserved (BYPASS) | Reserved for future RISC-V debugging
0x1f | BYPASS | JTAG requires this encoding</p>
<section id="idcode-0x01">
<h6>2.4.5.2.1 IDCODE(0X01)<a class="headerlink" href="#idcode-0x01" title="Link to this heading"></a></h6>
<p>When the TAP state machine is reset, this register (located in the Instruction Register, IR) is selected. Its definition is exactly consistent with that specified in the IEEE Standard 1149.1-2013.</p>
<p>This entire register is read-only.</p>
<p>31:28 | 27:12 | 11:1 | 0
:———–: | :———–: | :———–: | :———–:
vERSION | pARTnUMBER | mANUFLD | 1</p>
<p><strong>ManufId:</strong> Bits 6:0 must be the bits 6:0 of the design/manufacturer identification code specified by the JEDEC standard JEP106. Bits 10:7 contain the modulo-16 count of the continuation characters (0x7f) in the same identification code.</p>
</section>
<section id="dtm-control-and-status-dtmcs-0x10">
<h6>2.4.5.2.2  DTM Control and Status (dtmcs，0x10)<a class="headerlink" href="#dtm-control-and-status-dtmcs-0x10" title="Link to this heading"></a></h6>
<p>31:18 | 17 | 16 | 15 | 14:12 | 11:10 | 9:4 | 3:0
:———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–:|
0 | dmihardreset | dmireset | 0 | idle | dmistat | abits | version</p>
<p>| Field | Description | Access | Reset |
| :———–: | :———–: | :———–: | :———–: |
| dmihardreset | Writing a 1 to this bit performs a hard reset on the DTM, causing it to forget any ongoing DMI transactions. This should generally only be used when the debugger has reason to expect that the ongoing DMI transactions will never complete (e.g., reset conditions cause an in-progress DMI transaction to be aborted). | W | - |
| dmireset | Writing a 1 to this bit clears the error state and allows the DTM to retry or complete the previous transaction. | W | - |
| idle | This is a hint to the debugger regarding the minimum number of cycles it should spend in RunTest/Idle after each DMI scan to avoid returning the ‘busy’ code (dmistat is 3). The debugger must still check dmistat as necessary.  0: No need to enter Run-Test/Idle.   1: Enter Run-Test/Idle and exit immediately. 2: Enter Run-Test/Idle, stay for 1 cycle, then leave. | R  | Preset |
| dmistat | 0: No error. 1: Reserved. Interpretation is the same as for 2. 2: Operation failed (caused by op (2)). 3: Attempted operation while a DMI access is still in progress (caused by op (3)). | R      | 0      |
| abits | The size of the address in dmi. | R      | Preset |
| version | 0: Version described in specification version 0.11. 1: Version described in specification version 0.13. 15: Version not described in any available version of this specification. | R  | 1 |</p>
</section>
</section>
<section id="debug-module-interface-access-dmi-0x11">
<h5>2.4.5.3 Debug  Module Interface Access(dmi,0x11)<a class="headerlink" href="#debug-module-interface-access-dmi-0x11" title="Link to this heading"></a></h5>
<p>The Debug Module is subordinate to a bus known as the Debug Module Interface (DMI). The master of this bus is the Debug Transport Module (DTM). The Debug Module Interface can be a simple bus with a master and a slave, or it can utilize a more comprehensive bus, such as TileLink or AMBA Advanced Peripheral Bus. The details are left to the system designer.</p>
<p>DMI uses <strong>7 to 32 address bits</strong>. It supports <strong>read and write</strong> operations. The bottom of the address space is used for the first (often the only) DM. Additional space can be used for custom debug devices, other cores, additional DMs, etc. If there are additional DMs on this DMI, the base address of the next DM in the DMI address space is given in <code class="docutils literal notranslate"><span class="pre">nextdm</span></code>.</p>
<p>The Debug Module is controlled by accessing its DMI address space through registers.</p>
<p>| Field   | Description                                                  | Access | Reset |
| :———–: | :———–:                                                  | :———–: | :———-: |
| address | The address used for DMI access. This value is used for accessing the DM via DMI during Update-DR. | R/W | 0 |
| data    | The data sent to the DM via DMI during Update-DR, and the data returned by the DM after a previous operation. | R/W | 0 |
| op      | When the debugger writes this byte, the meanings are as follows: 0: Ignore data and address. Do not send anything via DMI during Update-DR. This operation will never result in a busy or error response. The address and data reported by the following Capture-DR are undefined. 1: Read from address. (Read) 2: Write data to address. (Write) 3: Reserved. | | |</p>
<p>When the debugger reads this byte, it indicates:<br />0: The previous operation was successfully completed.<br />1: Reserved.<br />2: The previous operation failed. The data scanned into dmi during this access will be ignored. This state is sticky and can be cleared by writing <code class="docutils literal notranslate"><span class="pre">dmireset</span></code> in <code class="docutils literal notranslate"><span class="pre">dtmcs</span></code>. This indicates that the DM itself responded with an error. There is no specific case for a DM to respond with an error, and DMI does not need to support returning an error.<br />3: An operation was attempted while a DMI request was still in progress. The data scanned into dmi during this access will be ignored. This state is sticky and can be cleared by writing <code class="docutils literal notranslate"><span class="pre">dmireset</span></code> in <code class="docutils literal notranslate"><span class="pre">dtmcs</span></code>. If the debugger sees this state, it needs to provide more TCK edges to the target between UpdateDR and Capture-DR. The simplest method is to add extra transitions in Run-Test/Idle.</p>
<p>To read an arbitrary Debug Module register, select dmi, scan a value with <code class="docutils literal notranslate"><span class="pre">op</span></code> set to 1, and set the address to the desired register address. During Update-DR, the operation will start, and the result of the operation will be captured as data during Capture-DR. If the operation does not complete in time, <code class="docutils literal notranslate"><span class="pre">op</span></code> will be 3, and the value in <code class="docutils literal notranslate"><span class="pre">data</span></code> must be ignored. The busy state must be cleared by writing <code class="docutils literal notranslate"><span class="pre">dmireset</span></code> in <code class="docutils literal notranslate"><span class="pre">dtmcs</span></code>, and a second scan must be performed. This process must be repeated until <code class="docutils literal notranslate"><span class="pre">op</span></code> returns 0. In subsequent operations, the debugger should allow more time between Capture-DR and Update-DR.</p>
<p>To write an arbitrary Debug Module register, select dmi, scan a value with <code class="docutils literal notranslate"><span class="pre">op</span></code> set to 2, and set the address and data to the desired register address and data, respectively. From that point on, everything is exactly the same as for a read, except that a write is performed instead of a read.</p>
<p>There is almost no need to scan the IR, thus avoiding most of the inefficiencies in typical JTAG usage.</p>
</section>
<section id="bypass">
<h5>2.4.5.4 BYPASS<a class="headerlink" href="#bypass" title="Link to this heading"></a></h5>
<p>This is an invalid 1-bit register, used when the debugger does not wish to communicate with this TAP. The entire register is read-only.</p>
</section>
<section id="debug-module-control-dmcontrol-0x10">
<h5>2.4.5.5 Debug Module Control (dmcontrol, 0x10)<a class="headerlink" href="#debug-module-control-dmcontrol-0x10" title="Link to this heading"></a></h5>
<p>31 | 30 | 29 | 28 | 27 | 26 | 25:16|15:6 | 5:4 | 3 | 2 | 1 | 0
:———–: | :———–: | :———–: | :———–: | :———–: | :———–: |:———–: |:———–: | :———–: | :———–: | :———–: | :———–: |:———–:
haltreq | resumereq | hartreset | ackhavereset | 0 | hasel | hartsello|hartselhi | 0 | setresethaltreq | clrresethaltreq | ndmreset | dmactive</p>
<p>| Field            | Description    | Access | Reset |
|:——————:|:———-:|:——–:|:——-:|
| haltreq          | Writing a 0 clears the halt request bit for all currently selected harts, potentially canceling outstanding halt requests for those harts. Writing a 1 sets the halt request bit for all currently selected harts. Running harts will stop when their halt request bit is set. The write applies to the new values of hartsel and hasel. | W      | -     |
| resumereq        | Writing a 1 will cause them to resume once if the currently selected harts are stopped at the time of the write operation. If haltreq is set, resumereq is ignored. The write applies to the new values of hartsel and hasel.                                                                                                                         | W      | -     |
| hartreset        | This optional bit writes the reset bit for all currently selected harts. To perform a reset, the debugger writes a 1, followed by a 0 to cancel the reset signal. While this bit is 1, the debugger cannot change the selected hart. If this feature is not implemented, the bit always remains 0, so the debugger can write 1 and then read the register to see if it is supported. | R/W    | 0     |
| ackhavereset     | 0: Invalid. 1: Clears the havereset bit for any selected hart. The write applies to the new values of hartsel and hasel.                                                                            | W1     | -     |
| hasel            | 0: There is currently one hart selected by hartsel. 1: There may be multiple harts currently selected, consisting of the hart selected by hartsel, plus any harts selected by the hart mask register.                                                                                 | R/W    | 0     |
| hartsello       | The lower 10 bits of hartsel: The dm-specific index of the hart to be selected. This hart is always part of the currently selected hart.                                                                                                   | R/W    | 0     |
| hartselhi       | The upper 10 bits of hartsel: The dm-specific index of the hart to be selected. This hart is always part of the currently selected hart.                                                                                                                                                                                                                   | R/W    | 0     |
| setresethaltreq | This optional bit writes the reset halt request bit for all currently selected harts unless clrresethaltreq is set to 1 at the same time. When set to 1, each selected hart will stop on the next reset. The reset request bit does not clear automatically. The debugger must write clrresethaltreq to clear it. The write applies to the new values of hartsel and hasel. hasresethaltreq = 0 indicates that this byte is not implemented. | W1     | -     |
| clrresethaltreq | This optional bit clears the reset request bit for all currently selected harts. The write applies to the new values of hartsel and hasel.                                                                                                                                                                                                                 | W1     | -     |
| ndmreset         | This bit controls the reset signal from the DM to the rest of the system. The signal should reset every part of the system, including each hart, except for the DM and any logic required to access the DM. To perform a system reset, the debugger writes a 1, followed by a 0 to cancel the reset.                                                                                                                          | R/W    | 0     |
| dmactive         | This bit acts as a reset signal for the debug module itself. 0: The module is in its reset state, including the authentication mechanism, with the exception of dynamic bits, which are the only bits that can be written to something other than their reset value. 1: The module is functioning normally.                                                                                                              | R/W    | 0     |</p>
</section>
<section id="debug-module-status-dmstatus-at-0x11">
<h5>2.4.5.6 Debug Module Status (dmstatus, at 0x11)<a class="headerlink" href="#debug-module-status-dmstatus-at-0x11" title="Link to this heading"></a></h5>
<p>This register reports the status of the entire debug module and the currently selected hart as defined in <code class="docutils literal notranslate"><span class="pre">hasel</span></code>. Its address will not change in the future because it contains version information.</p>
<p>The entire register is read-only.</p>
<p>31:23 | 22 | 21:20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3:0<br />:———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———–: | :———-: | :———–: | :———–: | :———–: | :———–:
0 | impebreak | 0 | allhavereset | anyhavereset | allresumeack | anyresumeack | allnonexistent | anynonexistent | allunavail | anyunavail | allrunning | anyrunning | allhalted | anyhalted | authenticated | authbusy | hasresethaltreq | confstrptrvalid | version</p>
<p>Field | Description | Access | Reset
:———–: | :———–: | :———–: | :———–:
impebreak | If set to 1, there is an implicit ebreak instruction at a non-existent word following the program buffer. This allows the debugger to avoid writing ebreak itself and allows the program buffer to be one word shorter. When proprobussize is 1, this value must be 1. | R | Preset
allhavereset | This bit is 1 when all currently selected harts have been reset and the reset has not been acknowledged. | R | -
anyhavereset | This bit is 1 when at least one currently selected hart has been reset and that hart has not acknowledged the reset. | R | -
allresumeack | This bit is 1 when all currently selected harts have acknowledged their last resume request. | R | -
anyresumeack | This bit is 1 when any currently selected hart has acknowledged its last resume request. | R | -
allnonexistent | This bit is 1 when the currently selected harts do not exist in this platform. | R | -
anynonexistent | This bit is 1 when the currently selected harts do not exist in this platform. | R | -
allunavail | This bit is 1 when all currently selected harts are unavailable. | R | -
anyunavail | This bit is 1 when any currently selected hart is unavailable. | R | -
allrunning | This bit is 1 when all currently selected harts are running. | R | -
anyrunning | This bit is 1 when any currently selected hart is running. | R | -
allhalted | This bit is 1 when all currently selected harts are halted. | R | -
anyhalted | This bit is 1 when any currently selected hart is halted. | R | -
authenticated | 0: Authentication is required before using the DM. 1: Authentication check passed. | R | Preset |
authbusy | 0: The authentication module is ready to process the next read of authdata. 1: The authentication module is busy. Accessing authdata will result in unspecified behavior. | R | 0 |
hasresethaltreq | 1: If this debug module supports the reset-halt feature controlled by setresethaltreq and clrresethaltreq bits. 0: Otherwise. | R | Preset |
confstrptrvalid | 0: confstrptr0{confstrptr3 stores information unrelated to the configuration string. 1: confstrptr0{confstrptr3 stores the address of the configuration string. | R | Preset |
version | 0: No debug module exists. 1: There is a debug module that complies with version 0.11 of this specification. 2: There is a debug module that complies with version 0.13 of this specification. 3: There is a debug module, but it does not comply with any available version of this specification. | R |  |</p>
</section>
<section id="abstract-control-and-status-abstractcs-at-0x16">
<h5>2.4.5.7 Abstract Control and Status (abstractcs, at 0x16)<a class="headerlink" href="#abstract-control-and-status-abstractcs-at-0x16" title="Link to this heading"></a></h5>
<p>31：29 | 28：24 | 23:13 | 12 | 11 | 10:8 | 7:4 | 3:0
:———–: | :———–: | :———–: | :———–:| :———–: | :———–: | :———–: | :———–:
0 | progbufsize | 0 | busy | 0 | cmderr | 0 | datacount</p>
<p>Sure, here is the professional English translation of the provided table:</p>
<p>Field | Description | Access | Reset
:———–: | :———–: | :———–: | :———–:
progbufsize | Size of the program buffer, represented in 32-bit words. Valid sizes range from 0 to 16. | R | Preset
busy | 1: Indicates that an abstract command is currently being executed. This bit is set immediately when the command is written and is cleared only after the command has completed. | R/W | 0
cmderr | Captures if an abstract command fails. The bits in this byte remain unchanged until they are cleared by writing 1 to them. No abstract command will be initiated until this value is reset to 0. This byte contains a valid value only when busy is 0. 0 (none): No error. 1 (busy): An abstract command is being executed when either command, abstractcs, or abstractauto is written, or when one of the data or program registers is read or written. This status can only be written when cmderr contains 0. 2 (not supported): The requested command is not supported, regardless of whether the hart is running or not. 3 (exception): An exception occurred during the execution of the command (e.g., while executing the program buffer). 4 (halt/resume): The abstract command cannot be executed because the hart is not in the required state (running/stopped) or is unavailable. 5 (bus): The abstract command failed due to a bus error (e.g., alignment, access size, or timeout). 7 (other): The command failed for other reasons. | R/W1C | 0
datacount | The number of data registers implemented as part of the abstract command interface. Valid lengths range from 1 to 12. | R | Preset-</p>
</section>
</section>
<section id="id33">
<h4>2.4.6 Checklist<a class="headerlink" href="#id33" title="Link to this heading"></a></h4>
</section>
</section>
<section id="qspi">
<h3>2.5 QSPI<a class="headerlink" href="#qspi" title="Link to this heading"></a></h3>
<section id="qspi-technical-specification">
<h4>2.5.1 QSPI Technical Specification<a class="headerlink" href="#qspi-technical-specification" title="Link to this heading"></a></h4>
<p><img alt="alt text" src="../_images/image-23.png" /></p>
<section id="id34">
<h5>Description<a class="headerlink" href="#id34" title="Link to this heading"></a></h5>
<p>SPI_1 is mounted on the MEISHAV100 as an SPI master, responsible for controlling external SPI data transfers. SPI_1 utilizes the open-source axi-spi-master code, which can be referenced at <a class="reference external" href="https://github.com/pulp-platform/axi_spi_master">https://github.com/pulp-platform/axi_spi_master</a>.</p>
</section>
<section id="id35">
<h5>Features<a class="headerlink" href="#id35" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p>Primarily designed for serial NOR Flash and ADC devices</p></li>
<li><p>Supports standard SPI, dual SPI, or quad-channel SPI commands</p>
<ul>
<li><p>Signal SD[0] may also be recognized by other</p></li>
<li><p>SPI masters as “MOSI,” while SD[3] is commonly referred to as “MISO”</p></li>
</ul>
</li>
<li><p>Separate FIFOs for RX and TX data</p>
<ul>
<li><p>288-byte capacity for TX data and 256-byte capacity for RX data</p></li>
<li><p>FIFO loading/unloading via 32-bit TL-UL registers</p></li>
<li><p>Supports arbitrary byte counts in each transaction</p></li>
</ul>
</li>
<li><p>SPI clock rate controlled by a separate input clock to the core</p>
<ul>
<li><p>SPI SCK line typically toggles at half the core clock frequency</p></li>
<li><p>An additional clock rate divider is available to reduce the frequency if needed</p></li>
</ul>
</li>
<li><p>Supports all SPI polarities and phases (CPOL, CPHA)</p>
<ul>
<li><p>Additional support for “full-cycle” SPI transactions, where data can be read after an entire SPI clock cycle (as opposed to the typical half cycle in SPI interfaces)</p></li>
</ul>
</li>
<li><p>Single Transfer Rate (STR) only (i.e., receiving data on multiple lines but only sampling data on one clock edge)</p>
<ul>
<li><p>Does not support Dual Transfer Rate (DTR)</p></li>
</ul>
</li>
<li><p>Pass-through mode for coordination with the SPI_DEVICE IP</p></li>
<li><p>Automatic control of the chip select signal line</p></li>
<li><p>Compact interrupt footprint: two lines corresponding to two distinct interrupt classes: “error” and “spi_event”</p>
<ul>
<li><p>Fine-grained interrupt masking provided by an auxiliary enable register</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="id36">
<h4>2.5.2 Theory of Operation<a class="headerlink" href="#id36" title="Link to this heading"></a></h4>
</section>
<section id="qspi-design-verification">
<h4>2.5.3 QSPI Design Verification<a class="headerlink" href="#qspi-design-verification" title="Link to this heading"></a></h4>
<p>Connect <code class="docutils literal notranslate"><span class="pre">spi_1</span></code> to the QSPI on MEISHAV100, and use data sent via <code class="docutils literal notranslate"><span class="pre">spi_1</span></code> to control QSPI for reading and writing memory.</p>
<section id="connecting-spi-1-and-qspi">
<h5>2.5.3.1 Connecting SPI_1 and QSPI<a class="headerlink" href="#connecting-spi-1-and-qspi" title="Link to this heading"></a></h5>
<p>Add the following code to the top-level file <strong>dut_MEISHAV100_TOP_wrapper.sv</strong>:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// spi_1 test</span>

<span class="k">assign</span><span class="w"> </span><span class="n">spi_slave_if</span><span class="p">.</span><span class="n">spi_sdo</span><span class="w">         </span><span class="o">=</span><span class="w">   </span><span class="n">spi_master_sdo</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">spi_master_sdi</span><span class="w">               </span><span class="o">=</span><span class="w">   </span><span class="n">spi_slave_if</span><span class="p">.</span><span class="n">spi_sdi</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">spi_slave_if</span><span class="p">.</span><span class="n">spi_clk</span><span class="w">         </span><span class="o">=</span><span class="w">   </span><span class="n">spi_master_clk</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">spi_slave_if</span><span class="p">.</span><span class="n">spi_csn</span><span class="w">         </span><span class="o">=</span><span class="w">   </span><span class="n">spi_master_csn</span><span class="p">[</span><span class="mh">0</span><span class="p">];</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">spi_slave_if</span></code> is a virtual interface added for testing QSPI, used to connect to QSPI. The <code class="docutils literal notranslate"><span class="pre">spi_master</span></code> signal is the <code class="docutils literal notranslate"><span class="pre">spi_1</span></code> signal brought out at the top level.</p>
</section>
<section id="writing-the-test-case">
<h5>2.5.3.2 Writing the Test Case<a class="headerlink" href="#writing-the-test-case" title="Link to this heading"></a></h5>
<p>Follow the structure of other test cases, primarily modifying the content within the <code class="docutils literal notranslate"><span class="pre">main_phase</span></code>:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="n">tl_agent_pkg</span><span class="o">::</span><span class="n">tl_host_single_seq</span><span class="w"> </span><span class="n">seq</span><span class="p">;</span>
<span class="n">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="s">&quot;seq&quot;</span><span class="p">);</span>
<span class="n">seq</span><span class="p">.</span><span class="n">control_addr_alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">control_rand_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">control_rand_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">override_a_source_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">overridden_a_source_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="p">;</span>

<span class="no">`DV_CHECK_RANDOMIZE_WITH_FATAL</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
<span class="w">  </span><span class="n">size</span><span class="w">             </span><span class="o">==</span><span class="w"> </span><span class="mh">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">mask</span><span class="w">             </span><span class="o">==</span><span class="w"> </span><span class="mh">&#39;hf</span><span class="p">;</span>
<span class="w">  </span><span class="n">source</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">write</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="p">)</span>

<span class="c1">// Initialize Mode and clock and data length, command and address length, Dummy cycles</span>

<span class="c1">// reset FIFO</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">&#39;h1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mh">4</span><span class="p">);</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>


<span class="c1">// set clock, spi_clk = axi_clk / (2 * (clk_div + 1))</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_CLKDIV</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h1</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="c1">// set data length and command to be 8 bits, address 0 bits</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPILEN</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">16&#39;h8</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">6&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">6&#39;h8</span><span class="p">};</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>


<span class="c1">// set write dummy cycles to be 0, read dummy cycles to be 33</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPIDUM</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">16&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">16&#39;h21</span><span class="p">};</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Select the values for the configuration registers based on whether QSPI transfer is used or not.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// if transmit by qspi mode, need to set reg0 of qspi to 1 </span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qspi_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPICMD</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mh">24</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0102</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_TXFIFO</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mh">24</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Start sending data from a specific address, and increment the address by 4 after each data transmission.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="c1">// set data length and address to be 32 bits, command 8 bits</span>
<span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPILEN</span><span class="p">;</span>
<span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">16&#39;h20</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">6&#39;h20</span><span class="p">,</span><span class="w"> </span><span class="mh">2&#39;h0</span><span class="p">,</span><span class="w"> </span><span class="mh">6&#39;h8</span><span class="p">};</span>
<span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="c1">// set initial address and data</span>
<span class="n">rw_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h5003</span><span class="n">_F060</span><span class="p">;</span>
<span class="n">write_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h1</span><span class="p">;</span>

<span class="k">repeat</span><span class="p">(</span><span class="mh">2000</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="no">`gfn</span><span class="p">,</span><span class="w"> </span><span class="n">$sformatf</span><span class="p">(</span><span class="s">&quot;spi_1 send data: %h&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">write_data</span><span class="p">),</span><span class="w"> </span><span class="n">UVM_NONE</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// write data to rw_addr</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPICMD</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0200</span><span class="n">_0000</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPIADR</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qspi_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0108</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0102</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_TXFIFO</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write_data</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">#</span><span class="mh">1000</span><span class="n">ns</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// read data from rw_addr, data will be stored in rxfifo</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPICMD</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0b00</span><span class="n">_0000</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_SPIADR</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">qspi_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0104</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_STATUS</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;h0101</span><span class="p">;</span>
<span class="w">        </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="p">#</span><span class="mh">1000</span><span class="n">ns</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// read data from spi_1 rxfifo</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">`SPI1_REG64_RXFIFO</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">seq</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">env</span><span class="p">.</span><span class="n">virtual_sequencer</span><span class="p">.</span><span class="n">match_sqr</span><span class="p">(</span><span class="s">&quot;tl&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;tile-RocketTile*tl_mem_mst&quot;</span><span class="p">));</span>

<span class="w">    </span><span class="n">rw_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mh">32&#39;h4</span><span class="p">;</span>
<span class="w">    </span><span class="n">write_data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mh">32&#39;h1</span><span class="p">;</span>
<span class="k">end</span>
</pre></div>
</div>
</section>
<section id="result-of-test">
<h5>2.5.3.3 Result of Test<a class="headerlink" href="#result-of-test" title="Link to this heading"></a></h5>
<p>Primarily test the address spaces for DDR and IRAM. The testing method involves separately testing the low, middle, and high parts of both address spaces. A portion of addresses in each part are tested. The test results are as follows:</p>
<p>Address | Result | Issue
:———–: | :———–: | :———–:
0x8000_0000~0x8000_9C40 (10000 addresses) | Correct |
0x9FFF_D1C0~0xA000_130C (10000 addresses) | Correct |
0xBFFF_63C0~0xC000_0000 (10000 addresses) | Partial Errors | The last three addresses read data as 0. After comparing waveforms and code, it was found to be an issue with the mounted VIP. Setting the working mode of the VIP mounted to <code class="docutils literal notranslate"><span class="pre">spi_1</span></code> to SLAVE resulted in correct operation.
0x5000_0000~0x5000_1F40 (2000 addresses) | Correct |
0x5003_F060~0x5004_0FA0 (2000 addresses) | Correct |
0x5007_E0C0~0x5008_0000 (2000 addresses) | Correct |</p>
</section>
<section id="software-testing">
<h5>2.5.3.4 Software Testing<a class="headerlink" href="#software-testing" title="Link to this heading"></a></h5>
<p>Translate the above SystemVerilog test code into C language code for software testing. The C code is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// See LICENSE for license details.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>


<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;platform.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;common.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spi1.h&quot;</span>

<span class="cp">#define QSPI 1</span>

<span class="cp">#define DEBUG</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;kprintf.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x80000000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x9FFFF830</span><span class="p">,</span><span class="w"> </span><span class="mh">0xBFFFF060</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50000000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50003830</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50007060</span><span class="p">};</span>
<span class="w">  </span>
<span class="w">    </span><span class="n">REG32</span><span class="p">(</span><span class="n">uart</span><span class="p">,</span><span class="w"> </span><span class="n">UART_REG_TXCTRL</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UART_TXEN</span><span class="p">;</span><span class="w">  </span><span class="c1">// donot delete</span>

<span class="w">    </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;Test begin ! @ core: %x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">read_csr</span><span class="p">(</span><span class="n">mhartid</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// reset fifo</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// set clock, spi_clk = axi_clk / (2 * (clk_div + 1))</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_CLKDIV</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x01</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// set data length and command to be 8 bits, address 0 bits</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPILEN</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x08</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x08</span><span class="p">;</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPIDUM</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x21</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// enable qspi transmit</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">QSPI</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPICMD</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">        </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0102</span><span class="p">;</span>
<span class="w">        </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_TXFIFO</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x01</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// set data length and address to be 32 bits, command 8 bits</span>
<span class="w">    </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPILEN</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x20</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x20</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x08</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// set initial address and data</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x12345678</span><span class="p">;</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">rw_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;DDR test begin!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;IRAM test begin!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// wait until SPI is idle</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x01</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// set write command and address</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPICMD</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x02</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPIADR</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// initiate a write operation with select CS0</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">QSPI</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0108</span><span class="p">;</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0102</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// wait until tx buffer has available place</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(((</span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// write data to addr</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_TXFIFO</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// wait until SPI is idle</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x01</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// set read command and address</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPICMD</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mh">0x0b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_SPIADR</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// initiate a write operation with select CS0</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">QSPI</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0104</span><span class="p">;</span>
<span class="w">            </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x0101</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// wait until rx buffer has available place</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(((</span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_STATUS</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xFF</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// read data from rxfifo</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">read_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_REG32</span><span class="p">(</span><span class="n">SPI1_BASE_ADDR</span><span class="p">,</span><span class="w"> </span><span class="n">SPI1_REG_RXFIFO</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">read_data</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;SPI1_TEST FAIL! at addr: %x, the correct data is: %x, but get: %x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">read_data</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;SPI1_TEST PASS! at addr: %x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">rw_addr</span><span class="p">);</span>

<span class="w">            </span><span class="n">rw_addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mh">0x4</span><span class="p">;</span>
<span class="w">            </span><span class="n">data</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;DDR test end!&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;IRAM test end!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;Test end ! @ core: %x&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">read_csr</span><span class="p">(</span><span class="n">mhartid</span><span class="p">));</span>


<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
<span class="w">        </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;PASS&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="p">{</span>
<span class="w">        </span><span class="n">kprintf</span><span class="p">(</span><span class="s">&quot;FAIL&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">kprintf</span><span class="p">(</span><span class="n">SHUTDOWN_FLAG_STR</span><span class="p">);</span><span class="w">  </span><span class="c1">// donnot delete</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p>Run the test case <code class="docutils literal notranslate"><span class="pre">soft_base_test.sv</span></code>. Mount the AXI VIP in the <code class="docutils literal notranslate"><span class="pre">initialize</span></code> function of the <code class="docutils literal notranslate"><span class="pre">soft_base_test_cfg</span></code> class to ensure QSPI operates normally.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="n">foreach</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_sw</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_sw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">ON</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">uvm_is_match</span><span class="p">(</span><span class="s">&quot;*vc707mig1gb*s_axi_slv*&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">SLAVE</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">uvm_is_match</span><span class="p">(</span><span class="s">&quot;*u_axi_spi_slave*m_axi_mst*&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">begin</span><span class="w"> </span><span class="c1">// for qspi</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">SLAVE</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">uvm_is_match</span><span class="p">(</span><span class="s">&quot;*vc707axi_to_pcie_x1*m_axi_slv*&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">ONLY_MONITOR</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">uvm_is_match</span><span class="p">(</span><span class="s">&quot;*vc707axi_to_pcie_x1*s_axi_mst*&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">SLAVE</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dv_utils_pkg</span><span class="o">::</span><span class="n">ONLY_MONITOR</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="no">`uvm_info</span><span class="p">(</span><span class="n">get_type_name</span><span class="p">(),</span><span class="w"> </span><span class="n">$sformatf</span><span class="p">(</span><span class="s">&quot;set_vip_agent_work_mode for inst_path %s, work_mode %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">axi_agent_work_mode</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">()),</span><span class="w"> </span><span class="n">UVM_DEBUG</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//this.m_axi_agent_cfg[i].if_mode = dv_utils_pkg::Host;  // donnot need add in here</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Then, run this test case, compile the above C code into a hex file and load it into the RAM. Run the simulation, and the simulation results are as follows:</p>
<p>Address | Result | Issue
:———–: | :———–: | :———–:
0x8000_0000~0x8000_0FA0 (500 addresses) | Correct |
0x9FFF_F830~0xA000_07D0 (500 addresses) | Correct |
0xBFFF_F060~0xC000_0000 (500 addresses) | Correct |
0x5000_0000~0x5000_0FA0 (500 addresses) | Correct |
0x5003_F830~0x5004_07D0 (500 addresses) | Correct |
0x5007_F060~0x5008_0000 (500 addresses) | Correct |</p>
</section>
</section>
<section id="id37">
<h4>2.5.4 Hardware Interfaces<a class="headerlink" href="#id37" title="Link to this heading"></a></h4>
<p>Signal | Direction | Description
:———–: | :———–: | :———–:
spi_clk | output | Master Clock
spi_csn0 | output | Chip Selcet0
spi_csn1 | output | Chip Selcet1
spi_csn2 | output | Chip Selcet2
spi_csn3 | output | Chip Selcet3
spi_mode[1:0] | output | SPI Mode
spi_sdo0 | output | Output Line0
spi_sdo1 | output | Output Line1
spi_sdo2 | output | Output Line2
spi_sdo3 | output | Output Line3
spi_sdi0 | input | Input Line0
spi_sdi1 | input | Input Line1
spi_sdi2 | input | Input Line2
spi_sdi3 | input | Input Line3</p>
</section>
<section id="id38">
<h4>2.5.5 Registers<a class="headerlink" href="#id38" title="Link to this heading"></a></h4>
<p>According to the pulpino documentation, the control registers and related functionalities for SPI_1 are as follows:</p>
<p>Offset | Name
:———–:| :———–:
0x00 | STATUS
0x08 | CLKDIV
0x10 | SPICMD
0x18 | SPIADR
0x20 | SPILEN
0x28 | SPIDUM
0x40 | TXFIFO
0x80 | RXFIFO</p>
<section id="status-status-register">
<h5>2.5.5.1 STATUS（Status Register）<a class="headerlink" href="#status-status-register" title="Link to this heading"></a></h5>
<p><strong>Reset Value：0x0000_0000</strong>
<img alt="alt text" src="../_images/38481e84-dde1-44ed-b3ca-65937ab976b5.png" /></p>
<ul class="simple">
<li><p><strong>Bit 11: 8  CS: Chip Select</strong>
Designates the chip select signal to be used for the next transfer.</p></li>
<li><p><strong>Bit 4   SRST: Software Reset</strong>
Clears the FIFO and terminates the ongoing transfer.</p></li>
<li><p><strong>Bit 3   QWR: Quad Write Command</strong>
Executes a write operation in QuadSPI mode.</p></li>
<li><p><strong>Bit 2   QRD: Quad Read Command</strong>
Executes a read operation in QuadSPI mode.</p></li>
<li><p><strong>Bit 1   WR: Write Command</strong>
Executes a write operation in standard SPI mode.</p></li>
<li><p><strong>Bit 0   RD: Read Command</strong>
Executes a read operation in standard SPI mode.</p></li>
</ul>
</section>
<section id="clkdiv-clock-divider">
<h5>2.5.5.2 CLKDIV（Clock Divider）<a class="headerlink" href="#clkdiv-clock-divider" title="Link to this heading"></a></h5>
<p><strong>Reset Value：0x0000_0000</strong>
<img alt="alt text" src="../_images/5327509c-1857-4e83-8258-c9a460d65269.png" /></p>
<ul class="simple">
<li><p><strong>Bit 7:0  CLKDIV: Clock Divider</strong>
The clock divider value, used to divide the SoC clock for SPI transfers. This register should not be modified during a transfer.</p></li>
</ul>
</section>
<section id="spicmd-spi-command">
<h5>2.5.5.3 SPICMD（SPI Command）<a class="headerlink" href="#spicmd-spi-command" title="Link to this heading"></a></h5>
<p><strong>Reset Value：0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/be818689-11e9-4643-9b37-3969e3aa2e00.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:0  SPICMD: SPI Command</strong>
When executing a read or write transfer, the SPI command is sent first before any data is read or written. The length of the SPI command can be controlled using the SPILEN register.</p></li>
</ul>
</section>
<section id="spiadr-spi-address">
<h5>2.5.5.4 SPIADR（SPI Address）<a class="headerlink" href="#spiadr-spi-address" title="Link to this heading"></a></h5>
<p><strong>Reset Value：0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/3f6ab307-a8e4-4258-a1c4-b2b35847373c.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:0  SPIADR: SPI Address</strong>
When performing a read or write transfer, the SPI command is sent first, followed by the SPI address, before any data is read or written. The length of the SPI address can be controlled using the SPILEN register.</p></li>
</ul>
</section>
<section id="spilen-spi-transfer-length">
<h5>2.5.5.5 SPILEN（SPI Transfer Length）<a class="headerlink" href="#spilen-spi-transfer-length" title="Link to this heading"></a></h5>
<p><strong>Reset Value：0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/bf22607e-923e-4f6f-8679-bad952a7b315.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:16  DATALEN: SPI Data Length</strong>
The number of bits to be read or written. Note that the SPI command and address are first written to the SPI slave device.</p></li>
<li><p><strong>Bit 13:8  ADDRLEN: SPI Address Length</strong>
The number of bits for the SPI address that should be sent.</p></li>
<li><p><strong>Bit 5:0  SPI Command Length</strong>
The number of bits for the SPI command that should be sent.</p></li>
</ul>
</section>
<section id="spidum-spi-dummy-cycles">
<h5>2.5.5.6 SPIDUM（SPI Dummy Cycles）<a class="headerlink" href="#spidum-spi-dummy-cycles" title="Link to this heading"></a></h5>
<p><strong>Reset Value：0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/fead8b77-1e4c-495d-947c-26f0f200ff17.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:16  DUMMYWR: Write Dummy Cycles</strong>
The number of dummy cycles (no write or read) between sending the SPI command + SPI address and writing data.</p></li>
<li><p><strong>Bit 15:0  DUMMYRD: Read Dummy Cycles</strong>
The number of dummy cycles (no write or read) between sending the SPI command + SPI address and reading data.</p></li>
</ul>
</section>
<section id="txfifo-spi-transmit-fifo">
<h5>2.5.5.7 TXFIFO (SPI Transmit FIFO)<a class="headerlink" href="#txfifo-spi-transmit-fifo" title="Link to this heading"></a></h5>
<p><strong>Reset Value: 0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/273da941-0aed-463d-b909-8f4df84aa9bb.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:0  TX: Transmit Data</strong>
Data to be written into the FIFO for transmission.</p></li>
</ul>
</section>
<section id="rxfifo-spi-receive-fifo">
<h5>2.5.5.8 RXFIFO (SPI Receive FIFO)<a class="headerlink" href="#rxfifo-spi-receive-fifo" title="Link to this heading"></a></h5>
<p><strong>Reset Value: 0x0000_0000</strong></p>
<p><img alt="alt text" src="../_images/3b08a5ca-6b21-4ab6-8dee-8c326cb5e1f5.png" /></p>
<ul class="simple">
<li><p><strong>Bit 31:0  RX: Receive Data</strong>
Data to be read from the FIFO received during transmission.</p></li>
</ul>
<p>Note: There seems to be a typo in the original text where “Transmit Data” is mentioned for both TX and RX. In the RXFIFO section, it should be “Receive Data” as corrected in the translation.</p>
</section>
<section id="id39">
<h5>2.5.6 Checklist<a class="headerlink" href="#id39" title="Link to this heading"></a></h5>
</section>
</section>
</section>
<section id="sram">
<h3>2.6 SRAM<a class="headerlink" href="#sram" title="Link to this heading"></a></h3>
<section id="sram-controller-technical-specification">
<h4>2.6.1 SRAM Controller Technical Specification<a class="headerlink" href="#sram-controller-technical-specification" title="Link to this heading"></a></h4>
<p><img alt="alt text" src="../_images/image-24.png" /></p>
<section id="id40">
<h5>Description<a class="headerlink" href="#id40" title="Link to this heading"></a></h5>
<p>The SRAM controller incorporates the SRAM data and address scrambling device and provides CSRs for requesting the scrambling keys and triggering the hardware initialization feature.
In the SRAM Controller of the hw platform, we added a Scramble module (acting on data and addr) and provided CSRs (used for requesting Scramble keys and triggering hardware initialization).
<a class="reference external" href="https://opentitan.org/book/hw/ip/sram_ctrl/doc/theory_of_operation.html">This summary draws reference from the content of the OpenTitan Hard-Ware article.</a>
This is an interpretat**ion of the hw part of the sram_ctrl code.</p>
</section>
<section id="id41">
<h5>Features<a class="headerlink" href="#id41" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p><strong>Lightweight scrambling mechanism</strong> based on the PRINCE cipher.</p></li>
<li><p>Key request logic for the lightweight memory and address scrambling device.</p></li>
<li><p>Alert sender and checking logic for detecting bus integrity failures.</p></li>
<li><p>LFSR-based memory initialization feature.</p></li>
<li><p>Access controls to allow / disallow code execution from SRAM.</p></li>
<li><p>Security hardening when integrity error has been detected.</p></li>
</ul>
</section>
</section>
<section id="id42">
<h4>2.6.2 Theory of Operation<a class="headerlink" href="#id42" title="Link to this heading"></a></h4>
<p>This section explains how the module controls external IRAM through software analysis.</p>
<div align=center><img src="photo/image-12.png" width="500"  alt="2">  
<div>
<div align=left><div>     <p>The main structure is concentrated on the left side of the diagram, with a hardware instance application on the right.</p>
<p>It is mainly divided into the following parts:</p>
<ul class="simple">
<li><p>TL-UL SRAM Adapter;</p></li>
<li><p>LFSR: Used for initialization (mechanism detailed in [1.2. Section](### 1.2. LFSR Initialization Mechanism));</p></li>
<li><p>CSRs;</p></li>
<li><p>Key request.</p></li>
</ul>
<section id="how-the-controller-handles-integrity-errors">
<h5>2.6.2.1 How the Controller handles Integrity Errors<a class="headerlink" href="#how-the-controller-handles-integrity-errors" title="Link to this heading"></a></h5>
<p>When encountering an <strong>Integrity Error</strong>, <code class="docutils literal notranslate"><span class="pre">sram_ctrl</span></code> will latch the integrity error and issue a <code class="docutils literal notranslate"><span class="pre">fatal_bus_integ_error</span></code> until the next reset (the generation of integrity errors is determined by system integration).</p>
<p>Additionally, the latched error condition is fed into the <code class="docutils literal notranslate"><span class="pre">prim_ram_1p_scr</span></code> primitive via a dedicated input, causing the scrambling primitive to perform the following actions:</p>
<ul class="simple">
<li><p>Invert the pseudorandom number used during address and CTR scrambling;</p></li>
<li><p>Disable any transactions (read or write) to the actual memory macro.</p></li>
</ul>
</section>
<section id="lfsr-initialization-mechanism">
<h5>2.6.2.2 LFSR Initialization Mechanism<a class="headerlink" href="#lfsr-initialization-mechanism" title="Link to this heading"></a></h5>
<p>Since the <strong>Scramble device</strong> uses a block cipher in CTR mode, from a security perspective, it is undesirable to initialize the memory to all zeros (this would leak the XOR keystream).</p>
<p>To avoid this, <code class="docutils literal notranslate"><span class="pre">sram_ctrl</span></code> includes an LFSR-based initialization mechanism that overwrites the entire memory with pseudo-random data.</p>
<p>Initialization can be triggered via the <code class="docutils literal notranslate"><span class="pre">CTRL.INIT</span></code> CSR. When initialization is triggered, the LFSR is first re-seeded using the obtained random number and the scrambling key. Then, the pseudo-random data extracted from the LFSR is used to initialize the memory.</p>
<p>For each pseudo-random 32-bit data, the initialization mechanism calculates the corresponding integrity bits and writes the data and integrity bits (a total of 39 bits) through the scrambling device using the most recently obtained scrambling key.</p>
<p>If the Scrambling Key update and LFSR initialization are triggered simultaneously on the software side (i.e., the software uses the same CSR write operation as the LFSR), the LFSR initialization will be halted until the updated Scrambling Key is obtained.</p>
<p>There is no limit on the frequency of calls to the initialization function, so it can also be used at runtime as a cheap SRAM erase mechanism. However, note that the PRNG sequence does not have strong security guarantees, as it is generated using an LFSR.</p>
</section>
<section id="executing-code-via-sram">
<h5>2.6.2.3. Executing Code via SRAM<a class="headerlink" href="#executing-code-via-sram" title="Link to this heading"></a></h5>
<p>The enable signal of the RAM ctrl is controlled by <code class="docutils literal notranslate"><span class="pre">otp_ctrl</span></code>;</p>
<div align=center><img src="photo/image-13.png" width="500"  alt="2">  
<div>
<div align=left><div>   </section>
<section id="read-and-write-sequences">
<h5>2.6.2.4. Read and Write Sequences<a class="headerlink" href="#read-and-write-sequences" title="Link to this heading"></a></h5>
<p>Combining the original text, the timing requirements for read and write operations are as follows:</p>
<ul class="simple">
<li><p>For timing reasons, the scrambling primitive instantiates a register in the middle of the PRINCE block cipher;</p></li>
<li><p>Write operations must be delayed by 1 cycle;</p></li>
<li><p>Sub-word write accesses currently require read-modify-write operations to recalculate the integrity bits of the entire word.</p></li>
</ul>
</section>
</section>
<section id="id43">
<h4>2.6.3 Design Verification<a class="headerlink" href="#id43" title="Link to this heading"></a></h4>
<p>The test plan objectives for the SRAM Controller (for dvsim) are as follows:</p>
<ul class="simple">
<li><p>Verify all SRAM_CTRL IP functionalities through dynamic simulations using SV/UVM-based test benches.</p></li>
<li><p>Develop and run all tests according to the test plan to close code and functional coverage for the IP and all its submodules (excluding pre-verified submodules).</p></li>
<li><p>Refer to the <a class="reference external" href="https://opentitan.org/book/hw/ip/sram_ctrl/dv/index.html#top-level-testbench">OpenTitan SRAM CTRL test plan</a> for specific test cases.</p></li>
</ul>
<section id="programming-guide">
<h5>Programming Guide<a class="headerlink" href="#programming-guide" title="Link to this heading"></a></h5>
<p>For software-side operational procedures, refer to the <a class="reference external" href="https://opentitan.org/book/hw/ip/sram_ctrl/doc/programmers_guide.html">OpenTitan SRAM CTRL software debugging guide</a>.</p>
</section>
</section>
<section id="id44">
<h4>2.6.4 Hardware Interfaces<a class="headerlink" href="#id44" title="Link to this heading"></a></h4>
<p>This section includes parameters, signals, security signals, and handshake signal behavior with external modules (including OTP and Scramble devices). The <strong>handshake signal behavior with external modules (including OTP and Scramble devices)</strong> is also described in terms of software-side security measures.</p>
</section>
<section id="parameters">
<h4>2.6.4.1 Parameters<a class="headerlink" href="#parameters" title="Link to this heading"></a></h4>
<p>| Parameter | Default | Top Earlgrey | Description |
| :———–: | :———–: | :———–: | :———–: |
| <code class="docutils literal notranslate"><span class="pre">AlertAsyncOn</span></code> | 1’b1 | 1’b1 | |
| <code class="docutils literal notranslate"><span class="pre">InstrExec</span></code> | 1 | 1 | Enable execution from SRAM side |
| <code class="docutils literal notranslate"><span class="pre">MemSizeRam</span></code> | 4096 | (multiple values) | Number of 32-bit words in SRAM (overridable by topgen) |
| <code class="docutils literal notranslate"><span class="pre">RndCnstSramKey</span></code> | (see RTL) | (see RTL) | Random default constant for Scrambling Key at compile time |
| <code class="docutils literal notranslate"><span class="pre">RndCnstSramNonce</span></code> | (see RTL) | (see RTL) | Random default constant for Scrambling Nonce at compile time |
| <code class="docutils literal notranslate"><span class="pre">RndCnstLfsrSeed</span></code> | (see RTL) | (see RTL) | Random default constant for LFSR seed at compile time |
| <code class="docutils literal notranslate"><span class="pre">RndCnstLfsrPerm</span></code> | (see RTL) | (see RTL) | Random default constants for LFSR permutation at compile time |</p>
</section>
<section id="external-signal-interfaces">
<h4>2.6.4.2 External Signal Interfaces<a class="headerlink" href="#external-signal-interfaces" title="Link to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">sram_ctrl</span></code> module defines the following hardware interfaces:</p>
<ul class="simple">
<li><p>Main clock: <code class="docutils literal notranslate"><span class="pre">clk_i</span></code></p></li>
<li><p>Other clocks (OTP device): <code class="docutils literal notranslate"><span class="pre">clk_otp_i</span></code></p></li>
<li><p>Bus device interface (TL-UL): <code class="docutils literal notranslate"><span class="pre">regs_tl</span></code>, <code class="docutils literal notranslate"><span class="pre">ram_tl</span></code></p></li>
<li><p>Bus host interface (TL-UL): none</p></li>
<li><p>Chip IO peripheral pins: none</p></li>
<li><p>Interrupts: none</p></li>
</ul>
</section>
<section id="internal-signal-interfaces">
<h4>2.6.4.3 Internal Signal Interfaces<a class="headerlink" href="#internal-signal-interfaces" title="Link to this heading"></a></h4>
<p>| Port Name | Package::Struct | Type | Act | Width | Description |
| :———–: | :———–:| :———–: | :———–: | :———–: | :———–: |
| <code class="docutils literal notranslate"><span class="pre">sram_otp_key</span></code> | <code class="docutils literal notranslate"><span class="pre">otp_ctrl_pkg::sram_otp_key</span></code> | <code class="docutils literal notranslate"><span class="pre">req_rsp</span></code> | <code class="docutils literal notranslate"><span class="pre">req</span></code> | 1 | |
| <code class="docutils literal notranslate"><span class="pre">cfg</span></code> | <code class="docutils literal notranslate"><span class="pre">prim_ram_1p_pkg::ram_1p_cfg</span></code> | <code class="docutils literal notranslate"><span class="pre">uni</span></code> | <code class="docutils literal notranslate"><span class="pre">rcv</span></code> | 1 | Routine signal cfg |
| <code class="docutils literal notranslate"><span class="pre">lc_escalate_en</span></code> | <code class="docutils literal notranslate"><span class="pre">lc_ctrl_pkg::lc_tx</span></code> | <code class="docutils literal notranslate"><span class="pre">uni</span></code> | <code class="docutils literal notranslate"><span class="pre">rcv</span></code> | 1 | Global and local upgrade enable |
| <code class="docutils literal notranslate"><span class="pre">lc_hw_debug_en</span></code> | <code class="docutils literal notranslate"><span class="pre">lc_ctrl_pkg::lc_tx</span></code> | <code class="docutils literal notranslate"><span class="pre">uni</span></code> | <code class="docutils literal notranslate"><span class="pre">rcv</span></code> | 1 | |
| <code class="docutils literal notranslate"><span class="pre">otp_en_sram_ifetch</span></code> | <code class="docutils literal notranslate"><span class="pre">prim_mubi_pkg::mubi8</span></code> | <code class="docutils literal notranslate"><span class="pre">uni</span></code> | <code class="docutils literal notranslate"><span class="pre">rcv</span></code> | 1 | |
| <code class="docutils literal notranslate"><span class="pre">regs_tl</span></code> | <code class="docutils literal notranslate"><span class="pre">tlul_pkg::tl</span></code> | <code class="docutils literal notranslate"><span class="pre">req_rsp</span></code> | <code class="docutils literal notranslate"><span class="pre">rsp</span></code> | 1 | |
| <code class="docutils literal notranslate"><span class="pre">ram_tl</span></code> | <code class="docutils literal notranslate"><span class="pre">tlul_pkg::tl</span></code> | <code class="docutils literal notranslate"><span class="pre">req_rsp</span></code> | <code class="docutils literal notranslate"><span class="pre">rsp</span></code> | 1 | |</p>
</section>
<section id="alert-signals">
<h4>2.6.4.4 Alert Signals<a class="headerlink" href="#alert-signals" title="Link to this heading"></a></h4>
<p>| Alert Name | Description |
| :———– | :———– |
| <code class="docutils literal notranslate"><span class="pre">fatal_error</span></code> | Triggered when a fatal TL-UL bus integrity failure or initialization mechanism reaches an invalid state. |</p>
</section>
<section id="safety-measures">
<h4>2.6.4.5 Safety Measures<a class="headerlink" href="#safety-measures" title="Link to this heading"></a></h4>
<p>| Countermeasure ID | Description |
| :———–: | :———–: |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.BUS.INTEGRITY</span></code> | End-to-end bus integrity scheme. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.CTRL.CONFIG.REGWEN</span></code> | SRAM control registers are protected by REGWEN. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.EXEC.CONFIG.REGWEN</span></code> | SRAM execution enable register is protected by REGWEN. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.EXEC.CONFIG.MUBI</span></code> | SRAM execution enable register is multi-bit encoded. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.EXEC.INTERSIG.MUBI</span></code> | SRAM execution enable signal from OTP is multi-bit encoded. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.LC_ESCALATE_EN.INTERSIG.MUBI</span></code> | Life cycle escalation enable signal is multi-bit encoded. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.LC_HW_DEBUG_EN.INTERSIG.MUBI</span></code> | Life cycle hardware debug enable signal is multi-bit encoded. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.MEM.INTEGRITY</span></code> | End-to-end data/memory integrity scheme. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.MEM.SCRAMBLE</span></code> | Data is scrambled using a key-reduced round PRINCE cipher in CTR mode. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.ADDR.SCRAMBLE</span></code> | Addresses are scrambled using a keyed lightweight permutation/diffusion function. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.INSTR.BUS.LC_GATED</span></code> | Prevent code execution from SRAM during non-test lifecycle states. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.RAM_TL_LC_GATE.FSM.SPARSE</span></code> | Control FSM within TL-UL gating primitive is sparse encoded. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.KEY.GLOBAL_ESC</span></code> | Scrambling key and nonce are reset to fixed values during escalation, and bus transactions to memory are blocked. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.KEY.LOCAL_ESC</span></code> | Scrambling key and nonce are reset to fixed values during local escalation due to bus integrity or counter errors, and bus transactions to memory are blocked. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.INIT.CTR.REDUN</span></code> | Initialization counter is redundant. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.SCRAMBLE.KEY.SIDELOAD</span></code> | Scrambling key is sideloaded from OTP and cannot be read by software. |
| <code class="docutils literal notranslate"><span class="pre">SRAM_CTRL.TLUL_FIFO.CTR.REDUN</span></code> | TL-UL response FIFO pointers are implemented using redundant counters. |</p>
<section id="interface-between-otp-and-sram-scrambling-primitives">
<h5>2.6.4.5.1 Interface between OTP and SRAM Scrambling Primitives<a class="headerlink" href="#interface-between-otp-and-sram-scrambling-primitives" title="Link to this heading"></a></h5>
<div align=center><img src="photo/image-14.png" width="500"  alt="2">  <div>
<div align=left><div>     <ul class="simple">
<li><p>The <strong>key derivation interface within OTP CTRL (i.e., <code class="docutils literal notranslate"><span class="pre">sram_otp_key</span></code>)</strong> follows a simple req/ack handshake protocol.</p>
<ol class="simple">
<li><p>SRAM CTRL requests an updated transient key by asserting <code class="docutils literal notranslate"><span class="pre">sram_otp_key_i.req</span></code>.</p></li>
<li><p>The OTP controller obtains the <code class="docutils literal notranslate"><span class="pre">entropy</span></code> signal from CSRNG (refer to CSRNG in hw) and derives the transient key using the <strong>SRAM_DATA_KEY_SEED</strong> and <strong>PRESENT</strong> scrambling data path (as described in the OTP controller specification).</p></li>
<li><p>The OTP controller returns a new transient key via the response channel (<code class="docutils literal notranslate"><span class="pre">sram_otp_key_o[*]</span></code>, <code class="docutils literal notranslate"><span class="pre">otbn_otp_key_o</span></code>), completing the req/ack handshake.</p></li>
</ol>
</li>
<li><p>The key and nonce are available for use by the scrambling primitives in subsequent cycles. The waveform diagram illustrates this process.</p></li>
<li><p>If key seeds are not configured in OTP, keys are derived from all-zero constants, and the <code class="docutils literal notranslate"><span class="pre">*.seed_valid</span></code> signal is set to 0 in the response. Note that this mechanism requires CSRNG and the entropy distribution network to be operational. If they are not, the key derivation request is blocked.</p></li>
<li><p>The req/ack protocol operates on <code class="docutils literal notranslate"><span class="pre">clk_otp_i</span></code>. SRAM CTRL synchronizes the data through the req/ack handshake primitive <code class="docutils literal notranslate"><span class="pre">prim_sync_reqack.sv</span></code>.</p></li>
</ul>
<div align=center><img src="photo/image-15.png" width="500"  alt="2">  <div>
<div align=left><div>    </section>
<section id="global-and-local-upgrades">
<h5>2.6.4.5.2 Global and Local Upgrades<a class="headerlink" href="#global-and-local-upgrades" title="Link to this heading"></a></h5>
<p>This section explains the functionality of <code class="docutils literal notranslate"><span class="pre">lc_escalate_en_i</span></code>:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">lc_escalate_en_i</span></code> signal is responsible for initiating global and local upgrades. When this signal is asserted, it triggers the system to perform necessary actions to upgrade the SRAM Controller and its associated components. This includes updating the scrambling keys, resetting counters, and ensuring the integrity of bus transactions to prevent unauthorized access or errors during the upgrade process. Global upgrades affect the entire system, while local upgrades focus on specific components, ensuring a controlled and secure update mechanism.</p>
</section>
</section>
<section id="register">
<h4>2.6.5 Register<a class="headerlink" href="#register" title="Link to this heading"></a></h4>
<p>Detailed reading of
<a class="reference external" href="https://opentitan.org/book/hw/ip/sram_ctrl/doc/registers.html">OpenTitan SRAM CTRL Register Configuration</a>,
here is the basic description.</p>
<p>Name | Offset | Length | Description
:———–: | :———–: | :———–: | :———–:
sram_ctrl.<strong>ALERT_TEST</strong> | 0x0 | 4 | Alert Test Register (1 bit for alert)
sram_ctrl.<strong>STATUS</strong> | 0x4 | 4 | SRAM Status Register (6 states; 1-bit thermal)
sram_ctrl.<strong>EXEC_REGWEN</strong> | 0x8 | 4 | Execution Enable Register Lock (EXEC’s enable)
sram_ctrl.<strong>EXEC</strong> | 0xc | 4 | SRAM Execution Enable (4 bits, related to OTG function)
sram_ctrl.<strong>CTRL_REGWEN</strong> | 0x10 | 4 | Control Register Lock (CTRL’s enable)
sram_ctrl.<strong>CTRL</strong> | 0x14 | 4 | SRAM Control Register (2 bits, related to OTG and LFSR control)
sram_ctrl.<strong>SCR_KEY_ROTATED</strong> | 0x18 | 4 | Clearable SRAM Key Request Status (4 bits, related to OTG function)</p>
</section>
<section id="external-interface-function">
<h4>2.6.6 External Interface Function<a class="headerlink" href="#external-interface-function" title="Link to this heading"></a></h4>
<p><code class="docutils literal notranslate"><span class="pre">dif_sram_ctrl.h</span></code></p>
</section>
<section id="id45">
<h4>2.6.7 Checklist<a class="headerlink" href="#id45" title="Link to this heading"></a></h4>
<p>Summary and design plan of the article.
To understand the specific functional implementation of SRAM CTRL, it is necessary to read the <strong>LFSR (CSRs)</strong> and <strong>OTP Controller</strong> sections.</p>
</section>
</section>
</section>
<section id="prototype-verificaton-on-fpga">
<h2>3. Prototype Verificaton On FPGA<a class="headerlink" href="#prototype-verificaton-on-fpga" title="Link to this heading"></a></h2>
<section id="fpga-development">
<h3>3.1 FPGA Development<a class="headerlink" href="#fpga-development" title="Link to this heading"></a></h3>
<section id="fpga-version">
<h4>3.1.1 FPGA Version<a class="headerlink" href="#fpga-version" title="Link to this heading"></a></h4>
<div align=center><img src="photo/c8536f24-c3ea-40e2-ae89-3ca79d2d68e1.png"  width="500"  alt="2">  <div>
<div align=left><div>     </section>
<section id="chiplink">
<h4>3.1.2 ChipLink<a class="headerlink" href="#chiplink" title="Link to this heading"></a></h4>
<p>Reference content from <a class="reference external" href="https://ysyx.oscc.cc/chip/board/official/boards/board-3/#fpga%E5%BC%80%E5%8F%91">YiShengYiChip Board FPGA Development</a>.</p>
<p><strong>Note: When tested on VC707, Chiplink will prompt that timing requirements cannot be met when using 150Mhz and 200Mhz clocks. Actual testing shows that 150Mhz works, but 200Mhz does not!</strong></p>
<p><strong>Note: The address range we use for Chiplink is 0x8000_0000~0xdfff_ffff. Read and write operations in other address ranges will cause Chiplink to report a slave_err.</strong></p>
</section>
<section id="fpga-side-block-design">
<h4>3.1.3 FPGA-side Block Design<a class="headerlink" href="#fpga-side-block-design" title="Link to this heading"></a></h4>
<div align=center><img src="photo/9a78c867-5af5-4ce5-9ad1-163e64f8f4a5.png"  width="600"  alt="2">  
<div>
<div align=left><div>   <ul>
<li><p><strong>ZYNQ7 Processing System</strong> - PS-side processor system</p>
<p>Requires the use of AXI_HP port</p>
<p>Clock use the clock provided by the PS side, frequency as needed (Chiplink module’s clock cannot use 200Mhz or higher, unable to meet timing requirements!)</p>
<p>Pin binding as needed, for example, the ZYBO 7020 development board can refer to the example</p>
</li>
<li><p><strong>AXI Interconnection</strong> - AXI intelligent interconnect module</p>
<p>Here, AXI Interconnection has two functions</p>
<ol class="simple">
<li><p>Synchronize AXI signals across clock domains, Chiplink uses a clock that is inconsistent with the DDR interface</p></li>
<li><p>Convert Chiplink’s AXI4 port signals to AXI3 port signals of the DDR interface</p></li>
</ol>
<p>The above operations are automatically completed by the AXI Interconnection module</p>
</li>
<li><p><strong>Processor System Reset</strong> - Synchronized reset module</p>
<p>Regardless of whether the reset signal is a synchronous or asynchronous reset, the Block Design will give serious warnings, requiring modification of port attributes, or all use synchronous reset</p>
<p>Therefore, Processor System Reset can be used to synchronize the reset signal to a certain clock, or a synchronized reset module can also be written (actually tested and works)</p>
</li>
<li><p><strong>Chiplink</strong> - Symmetric structure, has one master port and one slave port, two Chiplink are actually the same, only the masked ports are different when instantiated</p></li>
</ul>
</section>
<section id="ddr-read-and-write-test">
<h4>3.1.4  DDR Read and Write Test<a class="headerlink" href="#ddr-read-and-write-test" title="Link to this heading"></a></h4>
<p>In FPGA development, you can first verify that DDR is working normally by performing a DDR read and write test experiment on the board</p>
<p>In ZYNQ7020, you can complete the DDR read and write test by writing from the PL side and reading from the PS side using a serial port to print the content, specific pin assignment based on the actual situation binding</p>
<img src="photo/32975acb-c42e-4b00-b471-c04454f60737.png" width="800"  alt="UART">  <p>Add a state machine to send AXI signals to write DDR, Chiplink can be added or not, mainly to verify the operation of DDR.</p>
<p>Verification content: Single write DDR, Burst write DDR, etc.</p>
<p>The principle is simple, as follows:</p>
<div align=center><img src="photo/28a4faca-5e1f-458a-bccf-a7d4cd5e80ad.png" width="400"  alt="2">  <div>
<div align=left><div>   <p>Specific content and SDK side can refer to Altera’s video and project</p>
<p><a class="reference external" href="https://www.bilibili.com/video/BV11j411f7Co?p=66&amp;vd_source=343c7823aae26537eb54d42a934d7c12">65_AXI4 DDR Read and Write Test Experiment (Part 1)_bilibili</a></p>
</section>
</section>
<section id="preface">
<h3>3.2 Preface<a class="headerlink" href="#preface" title="Link to this heading"></a></h3>
<section id="notation-conventions">
<h4>3.2.1 Notation Conventions<a class="headerlink" href="#notation-conventions" title="Link to this heading"></a></h4>
<p>Text conventions used in the manual are specified in Table 1.</p>
</section>
<section id="supported-tools-and-environment-set-up">
<h4>3.2.2 Supported Tools and Environment Set Up<a class="headerlink" href="#supported-tools-and-environment-set-up" title="Link to this heading"></a></h4>
</section>
<section id="sw-requirements">
<h4>3.2.2.1 SW Requirements<a class="headerlink" href="#sw-requirements" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Operating environment
The project needs to run in ubuntu22.04.</p></li>
<li><p>Software dependence</p></li>
</ul>
<p>Firstly,following command below to git clone the project.<br /><code class="docutils literal notranslate"><span class="pre">$git</span> <span class="pre">clone</span> </code></p>
<p>Then Update software dependencies before downloading them.</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">sudo</span> <span class="pre">apt</span> <span class="pre">update</span></code><br /><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">sudo</span> <span class="pre">apt</span> <span class="pre">upgrade</span></code><br />Then install the software dependencies.</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">sudo</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">autoconf</span> <span class="pre">automake</span> <span class="pre">autotools-dev</span> <span class="pre">curl</span> <span class="pre">libmpc-dev</span> <span class="pre">libmpfr-dev</span> <span class="pre">libgmp-dev</span> <span class="pre">libusb-1.0-0-dev</span> <span class="pre">gawk</span> <span class="pre">build-essential</span> <span class="pre">bison</span> <span class="pre">flex</span> <span class="pre">texinfo</span> <span class="pre">gperf</span> <span class="pre">libtool</span> <span class="pre">patchutils</span> <span class="pre">bc</span> <span class="pre">zlib1g-dev</span> <span class="pre">device-tree-compiler</span> <span class="pre">pkg-config</span> <span class="pre">libexpat-dev</span> <span class="pre">python</span> <span class="pre">wget</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">sudo</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">default-jre</span></code></p>
<ul class="simple">
<li><p>Install the tool chain<br />Running the project also requires installing the required RISC-V toolchain for compilation on the software, the RISC-V software toolchain must be installed locally, and the $(RISCV) environment variable must be set to point to the installed RISC-V toolchain. You can start from scratch to build tool chain or at the following link to download: https://www.sifive.com/products/tools/, if you have installed the RISC-V toolchain, please run the following command.<br />Note: Do not include /bin at the end of the string.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">export</span> <span class="pre">RISCV=/home/riscv/riscv64-elf-tc</span></code></p>
<ul class="simple">
<li><p>Install vivado2016.4<br />This project tested can only use vivado2016.4 version to build, other newer versions will have errors.</p></li>
</ul>
</section>
<section id="hw-requirements">
<h4>3.2.2.2 HW Requirements<a class="headerlink" href="#hw-requirements" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>Supported development board</p></li>
</ul>
<p>Xilinx VC707(Virtex-7 XC7VX485T-2FFG1761C) is currently used in this project, and other types of FPGA boards have not been tested.</p>
</section>
</section>
<section id="introduction">
<h3>3.3 Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h3>
<p>The Soc built in this project was named MEISHAV100, which was built based on the freedom u500 of sifive Company, and the tilelink bus was replaced by the original pcie interface into the chiplink interface. iram, lsys, spi1 and qspi modules are added to make it have more debugging methods.</p>
<p>In order to accelerate processor prototyping and provide a flexible framework for hardware/software interface validation, the FPGA prototype based on this MEISHAV100 is publicly released. This version of the open source files include Verilog source code, Vivado project, bitstream files and related documentation, so that the majority of researchers and college students can quickly learn to copy the project, and easily transplant to other models of FPGA development board.</p>
<p>Due to the limitation of FPGA prototype verification, the current project only includes four Rocketchip processor cores, and the clock frequency of each module has certain limitations, which cannot achieve high frequency. See Figure 1 for details.</p>
</section>
<section id="prototype-architecture">
<h3>3.4 Prototype Architecture<a class="headerlink" href="#prototype-architecture" title="Link to this heading"></a></h3>
<section id="top-level-architecture">
<h4>3.4.1 Top Level Architecture<a class="headerlink" href="#top-level-architecture" title="Link to this heading"></a></h4>
<p>The overall architecture of MEISHAV100 is shown in Figure 1. In this project, MEISHAV100_TOP is the top layer of FPGA prototype verification project.</p>
<div align=center><img src="photo/image-7.png" width="500"  alt="2">  
<div>
<div align=left><div>     </section>
<section id="clock-and-reset">
<h4>3.4.2 Clock and Reset<a class="headerlink" href="#clock-and-reset" title="Link to this heading"></a></h4>
<p>After the clock of the VC707 on-board differential clock source is converted into a single-ended clock through an IBUFDS primitive, xilinx’s PLL IP core module will generate 3 CLKS, which are respectively provided to rockecttile, chiplink module and other sub. The chip is expected to support RocketTile using 1GHz clock, CHIPLINK module using 250M clock, and other modules using 500M clock, but currently in the FPGA prototype verification project, except chiplink module using 150MHz clock, other unified use 50MHz clock. Otherwise, too high a frequency will lead to timing violations.</p>
<p>The top layer ResetGEN module generates multiple resets, which are respectively provided to rockecttile, chiplink module and other subs. It is expected to support the reset signal generated after RocketTile uses 1G clock to beat, and the reset signal generated after CHIPLINK module uses 250M clock to beat. The reset signal generated after other modules use the 500M clock is supported. See Figure 2 for the reset timing diagram.</p>
<div align=center><img src="photo/image-8.png" width="600"  alt="2">    
Clock and reset time sequence diagram 
<div>
<div align=left><div>   </section>
<section id="peripheral-architecture">
<h4>3.4.3  Peripheral Architecture<a class="headerlink" href="#peripheral-architecture" title="Link to this heading"></a></h4>
<p>The peripherals of this project and the memory mapping of peripherals are shown below</p>
<p>|Base|Size|Description|Notes|<br />|:-:|:-:|:-:|:-:|
|0x0000_0000|4K|debug-controller||<br />|0x0000_3000|4K|error-device||<br />|0x0001_0000|8K|mask rom||<br />|0x0200_0000|64k|clink||<br />|0x0c00_0000|4M|plic||<br />|0x5000_0000|512K|on chip sram||<br />|0x5100_0000|4K|soc_lsys||<br />|0x5200_0000|4K|spi_1||<br />|0x6000_0000|64M|timeout||<br />|0x6400_0000|4K|serial|narrow or sparse is not supported|<br />|0x6400_1000|4K|spi_0|narrow or sparse is not supported|<br />|0x6400_2000|4K|gpio|narrow or sparse is not supported|<br />|0x8000_0000|1G|DDR(CHIPLINK)||<br />|0Xc000_0000|1G|timeout|this space is not accessible and access will case the bus to crash|</p>
</section>
<section id="chiplink-module">
<h4>3.4.4 Chiplink Module<a class="headerlink" href="#chiplink-module" title="Link to this heading"></a></h4>
<p>ChipLink is a low-speed interchip bus communication protocol (between FPGA and SoC) proposed by SiFive, which is mainly used for shard transmission and recombination of AXI4 requests sent by SoC to reliably access hardware logic resources on FPGA. The ChipLink controller Verilog code on the FPGA core board was generated by Chisel and has been emulated on the VCS.</p>
<p>Tilelink bus is mainly used in this project, so it is not necessary to convert AXI request into TileLink request. Instead, TileLink request can be directly converted into Chiplink request, and then SoC signal can be transmitted to FPGA through ChipLink transmission. The FPGA side needs to combine the TileLink request according to the ChipLink protocol, then convert the TileLink request back to the AXI request through the switching bridge, and finally exchange data with the MIG IP core on the FPGA through a series of switching Bridges, so as to realize the memory access operation of DDR on the FPGA.</p>
<p>Tested on VC707, when Chiplink uses 150MHz and 200MHz clocks, Vivado software will prompt that it cannot meet the timing requirements. However, the actual measured result is that Chiplink can still work normally at 150MHz, but not at 200MHz.</p>
<p>Note: The address range of the Chiplink we use is from <code class="docutils literal notranslate"><span class="pre">0x8000_0000</span></code> to <code class="docutils literal notranslate"><span class="pre">0xDfff_ffff</span></code>. Reading and writing Chiplinks in other address ranges will report a slave error.</p>
</section>
</section>
<section id="mapping-of-main-memory">
<h3>3.5 Mapping of Main Memory<a class="headerlink" href="#mapping-of-main-memory" title="Link to this heading"></a></h3>
<section id="using-on-board-ddr3-memory">
<h4>3.5.1 Using on-Board DDR3 Memory<a class="headerlink" href="#using-on-board-ddr3-memory" title="Link to this heading"></a></h4>
<p>All currently supported development boards have DDR3 memory on it. This allows us easily implement processor main memory using Xilinx MIG 7 IP core.</p>
</section>
<section id="added-iram-module">
<h4>3.5.2 Added IRAM Module<a class="headerlink" href="#added-iram-module" title="Link to this heading"></a></h4>
<p>Compared with Freedom U500, this project has added an IRAM module that can quickly access on-chip resources, mainly used to store frequently accessed stacks, hot data, hot programs, etc. The IRAM module supports axi fix and incr operation types, burst 1-16 operation types, narrow operation and sparse operation, but does not support wrap operation. Meanwhile, wstrb needs to be consistent with size, and invalid bits need to be set to 0.</p>
</section>
<section id="sd-card-as-external-memory">
<h4>3.5.3 SD Card as External Memory<a class="headerlink" href="#sd-card-as-external-memory" title="Link to this heading"></a></h4>
<p>The SDHC Card should conform to SD specification 2.00 or later. This project is currently using Kingston’s 64GB SDHC memory card and SD adapter.</p>
</section>
</section>
<section id="boot-mode-and-serial-terminal-settings">
<h3>3.6 Boot mode and Serial terminal settings<a class="headerlink" href="#boot-mode-and-serial-terminal-settings" title="Link to this heading"></a></h3>
<section id="start-up-process">
<h4>3.6.1 Start-up Process<a class="headerlink" href="#start-up-process" title="Link to this heading"></a></h4>
<p>The startup process of MEISHAV100 for this project is as follows:</p>
<p><strong>Power on → Run the boot program in the maskROM → Load the Linux image file bbl.bin in the SD card to the DDR → Start the Linux system</strong></p>
<p>The bootloader program stored in maskROM mainly completes loading and starting Linux image files from SD card to DDR storage, see Section 11 for details.</p>
<p>The construction of Linux image files stored in an SD card is detailed in Section 10.</p>
</section>
<section id="boot-mode-setup">
<h4>3.6.2 Boot Mode Setup<a class="headerlink" href="#boot-mode-setup" title="Link to this heading"></a></h4>
<p>The project currently supports two startup modes, namely starting from SD card and starting from IRAM, by binding the top-level signal DEBUG_MODE_SEL to the on-board DIP switch. If the signal is 0, it starts from the SD card boot program, and if the signal is 1, it starts from IRAM.</p>
</section>
<section id="serial-terminal-setup">
<h4>3.6.3 Serial Terminal Setup<a class="headerlink" href="#serial-terminal-setup" title="Link to this heading"></a></h4>
<p>Open a terminal connection from the host to the MEISHAV100 VC707 FPGA development board using programs such as Minicom or Screen on Linux, or MobaXterm on Windows. Set the parameters as shown below.<br />|Parameter|Value|<br />|:-:|:-:|<br />|Speed|115200|<br />|Parity|None|<br />|Data bits|8|<br />|Stop bits|1|<br />|Hardware Flow|None|</p>
</section>
</section>
<section id="prototype-operation">
<h3>3.7 Prototype Operation<a class="headerlink" href="#prototype-operation" title="Link to this heading"></a></h3>
<section id="reset-sequence">
<h4>3.7.1 Reset Sequence<a class="headerlink" href="#reset-sequence" title="Link to this heading"></a></h4>
<p>After reset button is pushed, the signal is converted to an internal system reset with zero active level.</p>
<p>If there is DDR controller,system reset is used for MIG XILINX IP core first.Until the initialization signal of the DDR controller is raised, then the DDR initialization is completed. The reset signal will only be used by the core.</p>
</section>
<section id="booting-os-from-an-sd-card">
<h4>3.7.2 Booting OS from an SD Card<a class="headerlink" href="#booting-os-from-an-sd-card" title="Link to this heading"></a></h4>
<p>Micro SD card allows to store both OpenBoot and OS image on it.Entering the OS with the sd card requires configured the clock frequency of uart and spi, and the default clock frequency of the processor is 50m. We have provided the pre-compiled linux systems that you can write into the sd card to run the linux system. Since you are unable to connect to the network on FPGA VC707, if you need to download the file on linux, you need to download the file into the linux system in the PC and write linux to the sd card.</p>
</section>
</section>
<section id="simulation-and-debugging">
<h3>3.8 Simulation and Debugging<a class="headerlink" href="#simulation-and-debugging" title="Link to this heading"></a></h3>
<p>It is possible to run software simulation of MEISHAV100 prototype from Vivado.This feature is helpful for debugging reset sequence for your project and checking initial initialization sequence of a processor. This framework can be easily extend to incorporate custom tests targeting prototype specific modules, but we leave this discussion out of scope of this documentation.</p>
<p>For debugging a processor on FPGA build-in hardware logic analyzer are used. It allows to check states of internal signals. Instructions on how to run software simulation from Vivado and how to add debug cores are below.</p>
<section id="software-simulation-from-vivado">
<h4>3.8.1 Software Simulation from Vivado<a class="headerlink" href="#software-simulation-from-vivado" title="Link to this heading"></a></h4>
<p>You can run simulation of a prototype from Vivado to debug initial processor initialization and warm up. Simulation from Vivado allows you to you IP cores used for synthesis and ensure that you logic is interpreted in an expected way. Top level module for simulation if fpga_top.It generates clock are reset control signals for prototype.</p>
<ul class="simple">
<li><p>Write tb.v file, the project has provided relatively simple simulation files, but if you have higher simulation requirements, please add the files required for the simulation</p></li>
<li><p>Click on Tools→click on settings→click on simulation →Compile Simulation Libraries</p></li>
<li><p>Click on simulation→Select the emulator that you wish to use.The recommended simulator to use is Vivado, as it don’t need to compile simulation libraries and configure the co-simulation.</p></li>
<li><p>In Flow Navigator on the left chose Simulation→Run behavioral Simulation. If you want to Post-Synthesis Functional Simulation, click on Functional Simulation.This requires first running the SYNTHESIS.</p></li>
</ul>
</section>
<section id="inserting-debug-cores-for-logic-analyzer">
<h4>3.8.2  Inserting Debug Cores for Logic Analyzer<a class="headerlink" href="#inserting-debug-cores-for-logic-analyzer" title="Link to this heading"></a></h4>
<p>Build-in logic analyzer allow you to debug FPGA design while  it’s running. Next steps briefly describe how to add debug cores.</p>
<ul class="simple">
<li><p>Find signals in the design which you want to debug. To make sure that Vivado doesn’t optimize the logic corre sponding and you will be able to access a signal with debug cores, add ( MARK_DEBUG = “TRUE” ) before it. This  directive works with flip-flops and ports, but can not work well with wires. If you need, add additional logic to flip-flop  signals.</p></li>
<li><p>Run Synthesis of a design</p></li>
<li><p>After synthesis finished, expand Open Synthesized Design tab of Flow Navigator and click on Set Up Debug</p></li>
<li><p>Follow the steps in the prompt to add signals for monitoring and to assign clock domain to them</p></li>
<li><p>Save the design and finish FPGA flow down to bitstream  generation  when programming FPGA from Vivado, in addition to .bit files specify .ltx files with debug signals names</p></li>
</ul>
</section>
</section>
<section id="block-design">
<h3>3.9  Block Design<a class="headerlink" href="#block-design" title="Link to this heading"></a></h3>
<p>The prototype was validated with Xilinx’s vivado2016.4 and connected to the module with its ip core via vivado’s block design capabilities. The Block Design diagram is shown under:</p>
<div align=center><img src="photo/image-11.png" width="600"  alt="2">  
<div>
<div align=left><div>   <p>Block Design diagram<br />The configurations of some ip cores are described below</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Utility</span> <span class="pre">Buffer</span></code>: click on page0→C size:1,C BUF Type :IBUFDS</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clk_wiz_0</span></code>: This is the clock for processor, set the input clock to 200m, the output clock clk_out 1, clk_out 2 to 50m, and set the high level reset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clk_wiz_1</span></code>:This is the clock for the DDR controller, set the input clock 200m, the output clock clk_out1 is 200m, set the high level reset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">process</span> <span class="pre">System</span> <span class="pre">Reset</span></code>:For changing the asynchronous reset of the input to a synchronous reset</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Axi</span> <span class="pre">interconnect</span></code>:The number of Master and Slave was all set at 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Memory</span> <span class="pre">Interface</span> <span class="pre">Generator</span></code>:This is the DDR controller module, used for controlling the DDR.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chiplink_master</span></code>:This is the rtl code we provide, and this module allows the core to control DDR through chiplink, which can reduce the pin interface compared to the axis bus.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DevKitWrapper</span></code>:This is the processor module, and some interfaces leave 0 unused because they are not used.</p></li>
</ul>
</section>
<section id="about-networking">
<h3>3.10 About Networking<a class="headerlink" href="#about-networking" title="Link to this heading"></a></h3>
<p>In this project, the PCIe interface of the original freedom U500 was replaced with a chiplink module, so MEISHAV100 could not be connected to the network for the time being. However, some bus matrices could be connected to the external chiplink interface in the future, and the MAC IP core of the FPGA board could be used to transmit network data on the bus matrix.</p>
</section>
<section id="generating-an-sd-bootable-image">
<h3>3.11 Generating an SD-Bootable Image<a class="headerlink" href="#generating-an-sd-bootable-image" title="Link to this heading"></a></h3>
<p>The Linux image file of this project needs to be built in ubuntu16.04 environment. In the ubuntu16.04 environment, run the following command to install and compile the required software package:</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">-y</span> <span class="pre">build-essential</span> <span class="pre">git</span></code> <code class="docutils literal notranslate"><span class="pre">autotools-dev</span> <span class="pre">texinfo</span> <span class="pre">bison</span> <span class="pre">flex</span> </code>
<code class="docutils literal notranslate"><span class="pre">libgmp-dev</span> <span class="pre">libmpfr-dev</span> <span class="pre">libmpc-dev</span> <span class="pre">gawk</span> <span class="pre">zlib1g-dev</span></code> <code class="docutils literal notranslate"><span class="pre">libssl-dev</span> <span class="pre">python</span> <span class="pre">unzip</span></code>
<code class="docutils literal notranslate"><span class="pre">libncurses5-dev</span> <span class="pre">libglib2.0-dev</span> <span class="pre">libpixman-1-dev</span></code> <code class="docutils literal notranslate"><span class="pre">device-tree-compiler</span> <span class="pre">ftp</span></code><br /><code class="docutils literal notranslate"><span class="pre">$wget</span> <span class="pre">cpio</span> <span class="pre">bc</span> <span class="pre">gdisk</span> <span class="pre">e2fsprogs</span> <span class="pre">vim</span></code></p>
<p>Then the overall sdk package this project uses the sdk package in the warehouse freedom-u-sdk. Clone the warehouse as follows:<br /><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">clone</span></code><br />https://github.com/mcd500/freedom-u-sdk.git<br /><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">checkout</span> </code><br />remotes/origin/linux_u500vc707devkit_config</p>
<p>After cloning, we still need to clone its sub repositories, but due to the fact that the freedom-usdk repository is too old, many of its sub repository URLs have been changed, which poses a problem of not being able to download directly using the recursive download command of the sub repository.</p>
<p>This project has updated the URLs of sub repositories that cannot be downloaded in the. gitmodules file. These updated. gitmodules files have been placed in the xx/xx/xx path. Please replace files in order, and execute the following command for each file replaced.</p>
<p>The steps are as follows:</p>
<p>1.Rename freedom-u-sdk.gitmodules to.gitmodules, and then replace the.gitmodules file in the freedom-u-sdk directory.</p>
<p>2.Run the following commands in sequence:<br /><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">sync</span></code><br /><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">update</span> <span class="pre">--init</span> <span class="pre">--recursive</span></code><br />3..Switch the sub-repository to the version specified by freedom-u-sdk.<br />4.Rename qemu.gitmodules to.gitmodules and replace the.gitmodules file under freedom-u-sdk/riscv-qemu.<br />5.Run the following commands in sequence:<br /><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">sync</span></code><br /><code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">update</span> <span class="pre">--init</span> <span class="pre">--recursive</span></code><br />6.Switch the sub-repository to the version specified by freedom-u-sdk.</p>
<p>7.Rename toolchain.gitmodules to.gitmodules and replace the.gitmodules file under freedom-u-sdk/riscv-gnu-toolchain.</p>
<p>8.Run the following commands in sequence:</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">sync</span></code>
<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">update</span> <span class="pre">--init</span> <span class="pre">--recursive</span></code></p>
<p>9.Switch the sub-repository to the version specified by freedom-u-sdk.</p>
<p>10.Rename toolchain-qemu.gitmodules to.gitmodules, and then replace the.gitmodules file under freedom-u-sdk/riscv-gnu-toolchain/riscv-qemu.</p>
<p>11.Run the following commands in sequence:
<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">sync</span></code>
<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">git</span> <span class="pre">submodule</span> <span class="pre">update</span> <span class="pre">--init</span> <span class="pre">--recursive</span></code></p>
<p>12.Switch the sub-repository to the version specified by freedom-u-sdk.</p>
<p>13.Finally, the complete download of freedom-u-sdk was completed</p>
<p>After completing the full clone of the repository, compile and execute the Linux image:</p>
<p><code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">make</span> <span class="pre">-j4</span> <span class="pre">BOARD=vc707devkit</span></code></p>
<p>After the Linux image is compiled and generated, you can find the generated image file, that is, the bbl.bin file, under the work folder. Use the following command to burn the bbl.bin to the SD card.
<code class="docutils literal notranslate"><span class="pre">$</span> <span class="pre">sudo</span> <span class="pre">dd</span>&#160; <span class="pre">if=bbl.bin</span> <span class="pre">of=/dev/sdb</span> <span class="pre">bs=512K</span> <span class="pre">count=1</span></code></p>
<p>If you need to add peripherals yourself, modify the
MEISHAV100.dts file, add the device tree of the corresponding device, and generate a dtb file to obtain driver support.</p>
</section>
<section id="compile-the-rom-boot-program">
<h3>3.12 Compile the ROM boot program<a class="headerlink" href="#compile-the-rom-boot-program" title="Link to this heading"></a></h3>
<p>The bootloader is sd.c located in the sdboot folder. Please use the gcc environment on the freedom library during compilation, otherwise an error will occur. The toolchain used is riscv64-unkown-elf-gcc. Please compile the toolchain provided by the freedom library and add the bin folder path of the toolchain to the system environment variable file.bashrc.</p>
<p>After modifying the sd.c file, you can use the make command in the sdboot folder to compile the sdboot.Hex file. You need to add the path of the file to the maskROM.</p>
</section>
</section>
<section id="backend">
<h2>4. Backend<a class="headerlink" href="#backend" title="Link to this heading"></a></h2>
<section id="memory">
<h3>4.1 Memory<a class="headerlink" href="#memory" title="Link to this heading"></a></h3>
<section id="memory-technical-specification">
<h4>4.1.1 Memory Technical Specification<a class="headerlink" href="#memory-technical-specification" title="Link to this heading"></a></h4>
<section id="id46">
<h5>Description<a class="headerlink" href="#id46" title="Link to this heading"></a></h5>
<p>A shell script has been developed to automatically generate the required memory using the memory compiler tool by filling in the parameters according to the example table.</p>
</section>
<section id="id47">
<h5>Features<a class="headerlink" href="#id47" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p>Developed a script that automatically generates the required memory using the memory compiler and captures the relevant parameter information to generate a report.</p></li>
<li><p>IP using UMC 40nm</p></li>
<li><p>Memory selection focuses on performance (read cycles) and area</p></li>
</ul>
</section>
</section>
<section id="id48">
<h4>4.1.2 Theory of Operation<a class="headerlink" href="#id48" title="Link to this heading"></a></h4>
<section id="script-functions">
<h5>4.1.2.1 Script Functions<a class="headerlink" href="#script-functions" title="Link to this heading"></a></h5>
<ul class="simple">
<li><p>Automated memory generation</p></li>
<li><p>Captures memory parameters, analyses them and generates a report.</p></li>
</ul>
</section>
<section id="environmental-requirements">
<h5>4.1.2.2 Environmental requirements<a class="headerlink" href="#environmental-requirements" title="Link to this heading"></a></h5>
<section id="operating-system-version">
<h6>4.1.2.2.1 Operating system version<a class="headerlink" href="#operating-system-version" title="Link to this heading"></a></h6>
<ul class="simple">
<li><p>Linux: any modern Linux distribution, such as Ubuntu 20.04 LTS, Fedora 34, CentOS 7, etc.</p></li>
<li><p>macOS: macOS 10.15 Catalina or later.</p></li>
<li><p>Other Unix-like systems: Any Unix-like system that supports Bash or other compatible shells.</p></li>
</ul>
</section>
<section id="programming-language-version">
<h6>4.1.2.2.2 Programming language version<a class="headerlink" href="#programming-language-version" title="Link to this heading"></a></h6>
<ul class="simple">
<li><p>Shell: Bash 4.0 or higher (the default version of Bash installed on most modern Linux distributions meets this requirement).</p></li>
</ul>
</section>
<section id="other-dependencies">
<h6>4.1.2.2.3 Other dependencies<a class="headerlink" href="#other-dependencies" title="Link to this heading"></a></h6>
<ul class="simple">
<li><p>A memory compiler with command line generation support.</p></li>
</ul>
</section>
</section>
<section id="usage-guidelines">
<h5>4.1.2.3 Usage Guidelines<a class="headerlink" href="#usage-guidelines" title="Link to this heading"></a></h5>
<section id="not-specifying-ip">
<h6>4.1.2.3.1 Not Specifying IP<a class="headerlink" href="#not-specifying-ip" title="Link to this heading"></a></h6>
<p>By entering the parameters in the input_data.csv file (in the format of the table below) and running the . /run_memaker.sh 2 command, a report in txt format can be generated according to the parameters in the first line, which covers all satisfied parameters of memory (such as area and read time).</p>
<p>| proc  | type | word | bit  | byte | ringtype | cksr | datasr | load |
| :—–: | :—-: | :—-: | :—-: | :—-: | :——–: | :—-: | :——: | :—-: |
| fsh0l | 1P   | 64   | 21   | 4    | ringless | 0.4  | 0.4    | 0.3  |
| fsh0l | 1P   | 8192 | 8    | 8    | ringless | 0.4  | 0.4    | 0.3  |</p>
</section>
<section id="specifying-ip">
<h6>4.1.2.3.2 Specifying IP<a class="headerlink" href="#specifying-ip" title="Link to this heading"></a></h6>
<p>Enter the parameters in input_ip.csv (in the form of the table below) and run the . /run_ip.sh 3 command to generate the verilog file and library file for the specified IP according to the parameters in the second line</p>
<p>| ip            | word | bit  | byte | mux  | ringtype | cksr | datasr | load |
| :————-: | :—-: | :—-: | :—-: | :—-: | :——–: | :—-: | :——: | :—-: |
| FSH0L_B_SHLVT | 64   | 21   | 4    | 4    | ringless | 0.4  | 0.4    | 0.3  |
| FSH0L_G_SHLVT | 8192 | 8    | 8    | 8    | ringless | 0.4  | 0.4    | 0.3  |</p>
</section>
</section>
<section id="report-output">
<h5>4.1.2.4 Report Output<a class="headerlink" href="#report-output" title="Link to this heading"></a></h5>
<section id="id49">
<h6>4.1.2.4.1 Not Specifying IP<a class="headerlink" href="#id49" title="Link to this heading"></a></h6>
<ul class="simple">
<li><p>The generated report is in txt format</p></li>
<li><p>The report contains the memory’s aspect, area, and read cycles.</p></li>
<li><p>The report also contains IP selected on the basis of minimum area and IP selected on the basis of minimum read cycles</p></li>
</ul>
</section>
<section id="id50">
<h6>4.1.2.4.2 Specifying IP<a class="headerlink" href="#id50" title="Link to this heading"></a></h6>
<ul class="simple">
<li><p>Generate verilog and library files based on IPs</p></li>
</ul>
</section>
</section>
</section>
</section>
<section id="i-o-cells-selections">
<h3>4.2 I/O Cells Selections<a class="headerlink" href="#i-o-cells-selections" title="Link to this heading"></a></h3>
<p>MEISHAV100 adopts the UMC 40 nm I/O cell library. I/O cell types are selected based on specific functional characteristics and alignment with project requirements. A final section provides the pin usage of the selected I/O cells.</p>
<section id="i-o-cell-type-selection">
<h4>4.2.1 I/O Cell Type Selection<a class="headerlink" href="#i-o-cell-type-selection" title="Link to this heading"></a></h4>
<p>I/O cells are categorized into the following types:</p>
<ul class="simple">
<li><p>analog I/O cells</p></li>
<li><p>the crystal oscillator I/O cells</p></li>
<li><p>tolerance generic POC I/O cells</p></li>
<li><p>supports the speed requirement of the DDR2 SDRAM interface I/O cells</p></li>
<li><p>supports SSTL-18,MDDR (LPDDR) and SSTL-2 modes I/O cells</p></li>
<li><p>multi-voltage generic POC I/O buffer cells</p></li>
</ul>
<p>This project selects I/O cells that support DDR2 SDRAM interface speeds and multi-voltage general-purpose POC I/O buffer units.</p>
</section>
<section id="selection-of-specific-i-o-cells">
<h4>4.2.2 Selection of Specific I/O Cells<a class="headerlink" href="#selection-of-specific-i-o-cells" title="Link to this heading"></a></h4>
<p>The I/O cell types were determined based on pin frequency and functional requirements of the project. Pin frequencies range from 25 MHz to 300 MHz, with the need for differential clocking. Ultimately, three I/O cells were selected.</p>
<p>The table below lists the I/O cells selected for this project.</p>
<p>| cell name                                                    | function                                              | sizes               | voltage&amp;frequency                            |
|:————————-: | :—————-:| :———: |:————-:|
| ZTRNE4GS<br />(FOH0L_QRS25_TMVH33L18<br />_GENERIC_POC_IO CELL LIBRARY) | Programmable 4.0 mA ~ 16 mA CMOS bidirectional buffer | 24.92μm x 169.4μm   | 3.3V:150MHz<br />2.5V:100MHz<br />1.8V:80MHz |
| WOSSTLECDLK<br />(FOH0L_QRS25_T18<br />_SSTL18A_IO CELL LIBRARY) | Differential bidirectional buffer                     | 70 µm x 252.98 µm   | 1.8v:supports DDR2 SRAM interface            |
| WRNE4GSLAX250<br />(FOH0L_QRS25_T18_GENERIC<br />_POC_IO_250 CELL LIBRARY SPECIFICATION) | Programmable 4.0 mA ~ 16 mA CMOS bidirectional buffer | 29.96 μm x 169.4 μm | 1.8v:250Mhz                                  |</p>
</section>
<section id="the-truth-table-for-i-o-selection">
<h4>4.2.3 The truth table for I/O selection<a class="headerlink" href="#the-truth-table-for-i-o-selection" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>ZTRNE4GSLA(WRNE4GSLAX250)</strong></p></li>
</ul>
<p>The table below summarizes the function and specific values for each pin</p>
<p>| E    | Output   |
| :—-: | :——–: |
| 0    | disabled |
| 1    | enabled  |</p>
<p>| IE   | Input    |
| :—-: | :——–: |
| 0    | disabled |
| 1    | enabled  |</p>
<p>| SR   | Slew rate |
| :—-:| :———: |
| 0    | fast      |
| 1    | slow      |</p>
<p>| SMT  | input           |
| :—-: | :—————: |
| 0    | normal          |
| 1    | schmitt-trigger |</p>
<p>| PU   | PD   | Pull-up/Pull-down       |
| :—-: | :—-: | :———————–: |
| 0    | 0    | None                    |
| 1    | 0    | 75-kΩ pull-up           |
| 0    | 1    | 75-kΩ pull-down         |
| 1    | 1    | keeper at IE=1          |
| 1    | 1    | 75-kΩ pull-down at IE=0 |</p>
<p>| E8   | E4   | driving capability |
| :—-: | :—-: | :——————: |
| 0    | 0    | 4<em>X                |
| 0    | 1    | 8</em>X                |
| 1    | 0    | 12<em>X               |
| 1    | 1    | 16</em>X               |</p>
<p>The following table represents the truth table for the selected I/O types</p>
<p>| I    | E    | IO          | IE   | O    |
| :—-: | :—-: | :———–: | :—-: | :—-: |
| 0    | 1    | 0           | 1    | 0    |
| 1    | 1    | 1           | 1    | 1    |
| 0    | 1    | 0           | 0    | 0    |
| 1    | 1    | 1           | 0    | 0    |
| X    | 0    | Z           | 1    | X    |
| X    | 0    | 1           | 1    | 1    |
| X    | 0    | 0           | 1    | 0    |
| X    | 0    | pull-down   | 1    | 0    |
| X    | 0    | pull-uo     | 1    | 1    |
| X    | 0    | none/keeper | 1    | IO   |
| X    | 0    | X           | 0    | 0    |</p>
<ul class="simple">
<li><p><strong>WOSSTLECDLK</strong></p></li>
</ul>
<p>The table below summarizes the function and specific values for each pin</p>
<p>| 信号        | 功能                                                         |
| :———–: | :———————–: |
| I           | Non-inverting input signal of the driver                     |
| E           | Output enable（‘1’enabled）                                  |
| IO          | Input pad of the receiver/Output pad of the driver           |
| IOB         | Inverted input pad of the receiver/Inverted output pad of the driver |
| E3V         | VCCK power-down detection pin（‘1’enabled）                  |
| SIO         | Single-ended mode/Differential mode selection pin（‘0’differential input mode/differential output mode） |
| NLEG5~NLEG0 | NMOS driving compensation control pins（Typ.default setting：010100） |
| PLEG5~PLEG0 | PMOS driving compensation control pins（Typ.default setting：010100） |
| REF         | Reference voltage of the single-ended receiver               |
| IE          | Input enable pin（‘1’enabled）                               |
| O           | Output signal of the receiver                                |
| RONMD2~0    | Output resistance selection pin                              |
| ODTEN       | ODT enable pin（‘1’enabled）                                 |
| ODTMD2~0    | ODT resistance selection                                     |
| D15V        | I/O power selection pin（’0‘：1.2v or 1.35v     ’1‘：1.5v or 1.8v） |
| MDDR1       | MDDR mode selection pin（’0’：DDR2 mode    ‘1’：LPDDR(MDDR)mode） |</p>
<p>the selection of the output driver impedance</p>
<p>| RONMD2 | RONMD1 | RONMD0 | Description |
| :——: | :——: | :——: | :———–: |
| 0      | 0      | 0      | 120Ω        |
| 0      | 0      | 1      | 120Ω        |
| 0      | 1      | 0      | 80Ω         |
| 0      | 1      | 1      | 60Ω         |
| 1      | 0      | 0      | Reserved    |
| 1      | 0      | 1      | 48Ω         |
| 1      | 1      | 0      | 40Ω         |
| 1      | 1      | 1      | 34.3Ω       |</p>
<p>On-die termination</p>
<p>| ODTMD2 | ODTMD1 | ODTMD0 | ODTEN | Description     |
| :——: | :——: | :——: | :—–: | :—————: |
| X      | X      | X      | 0     | ODT is disabled |
| 0      | 0      | 0      | 1     | ODT is disabled |
| 0      | 0      | 1      | 1     | 120Ω            |
| 0      | 1      | 0      | 1     | 60Ω             |
| 0      | 1      | 1      | 1     | 40Ω             |
| 1      | 0      | 0      | 1     | Reserved        |
| 1      | 0      | 1      | 1     | 30Ω             |
| 1      | 1      | 0      | 1     | 24Ω             |
| 1      | 1      | 1      | 1     | 20Ω             |</p>
</section>
</section>
</section>
<section id="device-sd">
<h2>5. DEVICE(SD)<a class="headerlink" href="#device-sd" title="Link to this heading"></a></h2>
<section id="sd-technical-specification">
<h3>5.1 SD Technical Specification<a class="headerlink" href="#sd-technical-specification" title="Link to this heading"></a></h3>
<section id="id51">
<h4>Description<a class="headerlink" href="#id51" title="Link to this heading"></a></h4>
<p>SD memory card is a new generation of memory device based on semiconductor flash memory, which is widely used in portable devices, such as digital cameras, smart phones and multimedia players, due to its excellent features such as small size, fast data transfer speed and hot-swappable.</p>
<p>SD cards have two communication modes, sdio and spi. The SPI mode consists of an auxiliary communication protocol provided by flash-based SD memory cards. This mode is a subset of the SD memory card protocol, and the interface is selected during the first reset command (CMD0) after power-on and cannot be changed once the device is powered on.</p>
<p>In the case of standard-capacity memory cards, data blocks can be as large as one card write block and as small as one byte. The card option specified in the CSD register enables partial block read/write operations.</p>
<p>In the case of high-capacity SD memory cards, the data block size is fixed at 512 bytes. the block length set by CMD16 is used only for CMD42 and not for memory data transfer. Therefore, partial block read/write operations are also disabled. In addition, write-protect commands (CMD28, CMD29 and CMD30) are not supported.</p>
</section>
<section id="id52">
<h4>Features<a class="headerlink" href="#id52" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>SD card verilog simulation model with spi mode (mode 0) support</p></li>
<li><p>High-capacity SD memory card (SDHC) with a size of 32GB</p></li>
<li><p>Operating voltage range of 2.7-3.6V</p></li>
<li><p>Support card initialization, write data, read data</p></li>
<li><p>Support commands including CMD0, CMD8, CMD12, CMD16, CMD17, CMD18, CMD24, CMD25, CMD55, CMD58, ACMD41 and so on.</p></li>
</ul>
</section>
</section>
<section id="id53">
<h3>5.2 Theory of Operation<a class="headerlink" href="#id53" title="Link to this heading"></a></h3>
<section id="spi-mode">
<h4>SPI Mode<a class="headerlink" href="#spi-mode" title="Link to this heading"></a></h4>
<p>SPI messages consist of commands, responses, and data block tokens. All communication between the host and the card is controlled by the host. The host initiates each bus process by setting the CS signal low.</p>
<p>The selected card always responds to commands, and when the card encounters a data retrieval problem during a read operation, it responds with an error response (replacing the expected block of data) rather than a timeout as in SD mode.</p>
<p>In addition, each data block sent to the card during a write operation will respond with a data response token.</p>
</section>
<section id="power-on">
<h4>Power-on<a class="headerlink" href="#power-on" title="Link to this heading"></a></h4>
<p>The state machine st waits 74 clock cycles in the PowerOn state and switches to the IDLE state when power-on is complete.</p>
</section>
<section id="receiving-commands">
<h4>Receiving Commands<a class="headerlink" href="#receiving-commands" title="Link to this heading"></a></h4>
<p>When a 48-bit command is transmitted on the mosi line, he first two bits 0x01 of the command is recognised and the state machine st switches from IDLE to CmdBit46 and then to CommandIn to receive the next 46 bits of data.</p>
</section>
<section id="responding-to-commands">
<h4>Responding to Commands<a class="headerlink" href="#responding-to-commands" title="Link to this heading"></a></h4>
<p>The state machine st receives the command in the CommandIn state and switches to CardResponse state, in which it responds to the command invocation function and the response is sent to the miso line.</p>
<p>After the response is sent the state machine st jumps to the corresponding state to complete the wait or read/write data operation according to the previously received command.</p>
</section>
<section id="card-initialisation">
<h4>Card Initialisation<a class="headerlink" href="#card-initialisation" title="Link to this heading"></a></h4>
<p>Use state machine ist to respond to initialisation commands and set init_done to 1 when the commands have all completed.</p>
</section>
<section id="clock-and-phase">
<h4>Clock and Phase<a class="headerlink" href="#clock-and-phase" title="Link to this heading"></a></h4>
<p>A maximum clock of 400KHz is required in Card Idntification Mode.
A maximum clock of 25MHz is required in Data Transfer Mode.</p>
<p>The SPI device module only internally supports mode 0, where data is shifted out on the falling edge and sampled on the rising edge.</p>
<p>The SPI device module internally supports mode 0, in which data is shifted out on the falling edge and sampled on the rising edge, and the SPI clock returns high at the end of the transaction.</p>
</section>
</section>
<section id="sd-card-design-verification">
<h3>5.3 SD Card Design Verification<a class="headerlink" href="#sd-card-design-verification" title="Link to this heading"></a></h3>
<section id="id54">
<h4>Goals<a class="headerlink" href="#id54" title="Link to this heading"></a></h4>
<section id="id55">
<h5>DV<a class="headerlink" href="#id55" title="Link to this heading"></a></h5>
<p>Verify SD card features by running dynamic simulations with a SV/UVM based testbench</p>
</section>
</section>
<section id="id56">
<h4>Design features<a class="headerlink" href="#id56" title="Link to this heading"></a></h4>
<p>For detailed information on UART design features, please see the <strong>SD Technical Specification</strong>.</p>
<section id="id57">
<h5>Testbench architecture<a class="headerlink" href="#id57" title="Link to this heading"></a></h5>
<section id="id58">
<h6>Top level testbench<a class="headerlink" href="#id58" title="Link to this heading"></a></h6>
<p>The top-level testbed is located in ‘\trunk\hw\d2dv100_top\dv’ and the SD card model is instantiated in dut_MEISHAV100_TOP_wrapper.sv.</p>
<p>| SD card signals | SD card signals given by the top-level module |  I/O   |
| :————-: | :——————————————-: | :—-: |
|      sclk       |                    spi_clk                    | output |
|      mosi       |                     MOSI                      | output |
|      miso       |                     MISO                      | input  |
|       ncs       |                     SS_n                      | output |
|      rstn       |                   spi_rst_n                   | output |</p>
</section>
</section>
</section>
<section id="stimulus-strategy">
<h4>Stimulus strategy<a class="headerlink" href="#stimulus-strategy" title="Link to this heading"></a></h4>
<p>This test was modified based on the sd.c code written for the Freedom U500.</p>
</section>
<section id="self-checking-strategy">
<h4>Self-checking strategy<a class="headerlink" href="#self-checking-strategy" title="Link to this heading"></a></h4>
<p>Provide the spi port on the soc to send data to the spi-slave to see if the spi-slave can send back the correct value.</p>
<p>In the main function, send data to spi_txfifo via REG32(spi, SPI_REG_TXFIFO), then the spi will automatically send the data from the txfifo, and we only need to check if the mosi port is correctly outputting in the monitor. Since the txfifo can only send one byte of data at a time, choosing 0x00~0xff as the test data will cover all cases.</p>
</section>
<section id="id59">
<h4>5.3.1 Testplan<a class="headerlink" href="#id59" title="Link to this heading"></a></h4>
<section id="sd-card-initialisation-test">
<h5>5.3.1.2 SD card initialisation test<a class="headerlink" href="#sd-card-initialisation-test" title="Link to this heading"></a></h5>
<p>The SD card needs to be initialised before performing data read and write operations.
<strong>Power-on and clock pulse sending</strong>:</p>
<ul class="simple">
<li><p>After the SD card is powered on, the host needs to send at least 74 clock pulses to the SD card. This is because the SD card needs about 64 clock cycles to reach the normal operating voltage, after which 10 clock cycles are used to synchronise with the SD card.</p></li>
<li><p>During this time, the chip select signal ncs and the master output slave input signal mosi should be held high.</p></li>
</ul>
<p><strong>Send CMD0 command</strong>:</p>
<ul class="simple">
<li><p>The chip select signal ncs is pulled low and the CMD0 (0x40) command is sent to the SD card with parameters 0x00_00_00_00_00 and CRC check bit 0x95.</p></li>
<li><p>This command is used to reset the SD card. After the command is sent, wait for the SD card to return the response data R1.</p></li>
</ul>
<p><strong>Check CMD0 response:</strong></p>
<ul class="simple">
<li><p>Check the returned response data R1. If R1 is 0x01, it indicates that the SD card is in idle state and you can enter SPI mode and continue to the next step. If R1 is any other value, you need to re-execute step 2.</p></li>
<li><p>Wait for 8 clock cycles and then pull up the chip select signal ncs.</p></li>
</ul>
<p><strong>Send CMD8 command</strong>:</p>
<ul class="simple">
<li><p>Pull down the chip select signal ncs again and send CMD8 (0x48) command with parameter 0x00_00_01_AA.</p></li>
<li><p>This command is used to query the version number of the SD card. After the command is sent, wait for the SD card to return the response data R7.</p></li>
</ul>
<p><strong>Check CMD8 response</strong>:</p>
<ul class="simple">
<li><p>Check the returned response data. If R1 is 0x05, the SD card is not an SD 2.0 card. If R1 is 0x01 and the 32-bit parameter is 0x00_00_01_AA, it is judged to be an SD 2.0 card. If the returned data is incorrect, step 4 needs to be performed again.</p></li>
<li><p>Wait for 8 clock cycles and pull up the chip select signal ncs.</p></li>
</ul>
<p><strong>Sends APP_CMD (CMD55), the precursor command to the ACMD41 command</strong>:</p>
<ul class="simple">
<li><p>Pull down the chip select signal ncs and send CMD55 (0x77) command to inform the SD card that the next send is a application-specific command.</p></li>
<li><p>Wait for the SD card to return the response data R1, check if R1 is 0x01. if yes, continue to the next step; if no, re-execute step 6.</p></li>
</ul>
<p><strong>Send ACMD41 command</strong>:</p>
<ul class="simple">
<li><p>Pull down the chip select signal ncs and send the ACMD41 (0x69) command to query the SD card initialisation result.</p></li>
<li><p>Wait for SD card to return response data R1.</p></li>
</ul>
<p><strong>Check ACMD41 response</strong>:</p>
<ul class="simple">
<li><p>Check R1 in the returned response data R3. if R1 is 0x00, initialisation is complete. If not, it is necessary to re-execute step 6 until the initialisation is successful.</p></li>
<li><p>Wait for 8 clock cycles and then pull up the chip select signal ncs.</p></li>
</ul>
<p>The above steps outline the initialisation process for SD 2.0 specification SD cards, ensuring that the SD card has been correctly initialised prior to data reading and writing.3.5.2</p>
</section>
<section id="sd-card-data-write-test">
<h5>5.3.1.3 SD card data write test<a class="headerlink" href="#sd-card-data-write-test" title="Link to this heading"></a></h5>
<p>After the initialisation of the SD card is completed, the data writing operation is performed first, and then the written data is read out and verified.</p>
<section id="single-block-write-operation">
<h6>5.3.1.3.1 Single Block Write Operation<a class="headerlink" href="#single-block-write-operation" title="Link to this heading"></a></h6>
<p><strong>Send Write Command</strong>:</p>
<ul class="simple">
<li><p>Pull down the chip select signal ncs.</p></li>
<li><p>Send the CMD24 command (0x58) to the SD card, carrying the 4-byte SD card write sector address as a parameter.</p></li>
<li><p>The CRC check byte is not used and is written directly to 0xAA.</p></li>
<li><p>After the command is sent, wait for the SD card to return the response data.</p></li>
</ul>
<p><strong>Check response and write data</strong>:</p>
<ul class="simple">
<li><p>If the SD card returns the correct response data R1 is 0x00, wait 8 clock cycles.</p></li>
<li><p>Write token 0xFE to the SD card, immediately followed by a 512-byte block of data.</p></li>
</ul>
<p><strong>Write CRC</strong>:</p>
<ul class="simple">
<li><p>In SPI mode, no CRC check is performed on the data, and two bytes of 0xFF are written directly as the CRC check byte.</p></li>
</ul>
<p><strong>Waiting for SD card response</strong>:</p>
<ul class="simple">
<li><p>After the verification data is sent, the SD card returns the response data.</p></li>
<li><p>The SD card then pulls the MISO signal low and enters the write busy state.</p></li>
</ul>
<p><strong>Write operation complete</strong>:</p>
<ul class="simple">
<li><p>Wait for the MISO signal to be pulled high again to indicate that the SD card exits the write busy state.</p></li>
<li><p>Wait for 8 clock cycles and then pull up the chip select signal ncs.</p></li>
<li><p>At this point, the SD card data write operation is complete and other operations can be performed.</p></li>
</ul>
</section>
<section id="multiple-block-write-operation">
<h6>5.3.1.3.2 Multiple Block Write Operation<a class="headerlink" href="#multiple-block-write-operation" title="Link to this heading"></a></h6>
<p><strong>Send write command</strong>:</p>
<ul class="simple">
<li><p>Pull down the chip select signal ncs.</p></li>
<li><p>Send a CMD25 command (0x59) to the SD card, carrying the 4-byte SD card write sector address as a parameter.</p></li>
<li><p>The CRC check byte is not used and is written directly to 0xAA.</p></li>
<li><p>After the command is sent, wait for the SD card to return the response data.</p></li>
</ul>
<p><strong>Check response and write data</strong>:</p>
<ul class="simple">
<li><p>If the SD card returns the correct response data R1 is 0x00, wait for 8 clock cycles.</p></li>
<li><p>Write token 0xFC to the SD card, immediately followed by a 512-byte block of data.</p></li>
</ul>
<p><strong>Write CRC check byte</strong>:</p>
<ul class="simple">
<li><p>In SPI mode, no CRC check is performed on the data, and two bytes of 0xFF are written directly as the CRC check byte.</p></li>
</ul>
<p><strong>Wait for SD card response</strong>:</p>
<ul class="simple">
<li><p>After the check data is sent, the SD card will return the response data.</p></li>
<li><p>The SD card then pulls the MISO signal low and enters the write busy state.</p></li>
</ul>
<p><strong>Continue to send data block</strong>:</p>
<ul class="simple">
<li><p>Wait for the MISO signal to pull high again to indicate that the SD card exits the write busy state.</p></li>
<li><p>Write token 0xFC to the SD card, immediately followed by a 512-byte data block.</p></li>
</ul>
<p><strong>Write CRC check byte</strong>:</p>
<ul class="simple">
<li><p>In SPI mode, no CRC check is performed on the data, and two bytes of 0xFF are written directly as the CRC check byte.</p></li>
</ul>
<p><strong>Wait for SD card response</strong>:</p>
<ul class="simple">
<li><p>After the check data is sent, the SD card will return the response data.</p></li>
<li><p>The SD card then pulls the MISO signal low and enters the write busy state.</p></li>
</ul>
<p><strong>Write operation complete</strong>:</p>
<ul class="simple">
<li><p>Wait for the MISO signal to pull high again to indicate that the SD card exits the write busy state.</p></li>
<li><p>Send the write end token 0xFD.</p></li>
<li><p>Wait for 8 clock cycles and then pull up the chip select signal ncs.</p></li>
<li><p>At this point, the SD card data write operation is complete and other operations can be performed.</p></li>
</ul>
<p>The above steps outline the process of SD card data writing to ensure that the data can be correctly written to the specified sectors of the SD card, and to perform the necessary status checks after the writing is complete.</p>
</section>
</section>
<section id="sd-card-data-reading-test">
<h5>5.3.1.4 SD card data reading test<a class="headerlink" href="#sd-card-data-reading-test" title="Link to this heading"></a></h5>
<p>After the SD card has been initialised and data written, the operation of reading and verifying the data is performed next.</p>
</section>
<section id="single-block-read-operation">
<h5>5.3.1.4.1 Single Block Read Operation<a class="headerlink" href="#single-block-read-operation" title="Link to this heading"></a></h5>
<p><strong>Send read command</strong>:</p>
<ul class="simple">
<li><p>Pull down the chip select signal ncs.</p></li>
<li><p>Send the CMD17 command (0x51) to the SD card, carrying the 4-byte SD card read sector address as a parameter.</p></li>
<li><p>The CRC check byte is not used and is written directly to 0xFF.</p></li>
<li><p>After the command is sent, wait for the SD card to return the response data.</p></li>
</ul>
<p><strong>Check the response and read the data</strong>:</p>
<ul class="simple">
<li><p>If the SD card returns the correct response data R1 is 0x00, prepare to receive the data using the data header 0xFE returned by the SD card as a flag.</p></li>
<li><p>Receive 512 bytes of data read from SD card and 2 bytes of CRC check byte.</p></li>
</ul>
<p><strong>Parsing data</strong>:</p>
<ul class="simple">
<li><p>After confirming data token 0xFE, receive 512 bytes of data returned from SD card.</p></li>
<li><p>After data parsing is completed, receive two bytes of CRC check value. In SPI mode, no CRC check is performed on the data, so these two bytes can be ignored.</p></li>
</ul>
<p><strong>Read operation complete</strong>:</p>
<ul class="simple">
<li><p>After the CRC check byte is received, wait for 8 clock cycles.</p></li>
<li><p>Pulling up the chip select signal ncs marks the completion of a data read operation.</p></li>
</ul>
</section>
<section id="multiple-block-read-operation">
<h5>5.3.1.4.2 Multiple Block Read Operation<a class="headerlink" href="#multiple-block-read-operation" title="Link to this heading"></a></h5>
<p><strong>Send read command</strong>:</p>
<ul class="simple">
<li><p>Pull down the chip select signal ncs.</p></li>
<li><p>Send the CMD18 command (0x52) to the SD card, carrying the 4-byte SD card read sector address as a parameter.</p></li>
<li><p>The CRC check byte is not used and is written directly to 0xFF.</p></li>
<li><p>After the command is sent, wait for the SD card to return the response data.</p></li>
</ul>
<p><strong>Check the response and read the data</strong>:</p>
<ul class="simple">
<li><p>If the SD card returns the correct response data R1 is 0x00, prepare to receive the data using the data token 0xFE returned by the SD card as a flag.</p></li>
<li><p>Receive 512 bytes of data read from SD card and 2 bytes of CRC check byte.</p></li>
</ul>
<p><strong>Parsing data</strong>:</p>
<ul class="simple">
<li><p>After confirming data token 0xFE, receive 512 bytes of data returned from SD card.</p></li>
<li><p>After data parsing is completed, receive two bytes of CRC check value. In SPI mode, no CRC check is performed on the data, so these two bytes can be ignored.</p></li>
</ul>
<p><strong>Interrupt reading</strong>:</p>
<ul class="simple">
<li><p>Send the abort command cmd12 (0x4c), the abort command can be sent at any time, when 512 bytes are sent, stop sending data.</p></li>
<li><p>If cmd12 is not sent, it will continue to read the next data block.</p></li>
</ul>
<p><strong>Read operation completed</strong>:</p>
<ul class="simple">
<li><p>After the CRC check byte is received, wait for 8 clock cycles.</p></li>
<li><p>Pull up the chip select signal ncs to mark the completion of a data read operation.</p></li>
</ul>
<p>The above steps ensure that the previously written data is correctly read from the SD card and the necessary verification is performed.</p>
</section>
</section>
</section>
<section id="id60">
<h3>5.4 Hardware Interfaces<a class="headerlink" href="#id60" title="Link to this heading"></a></h3>
<section id="sd-card-i-o">
<h4>5.4.1 SD card I/O<a class="headerlink" href="#sd-card-i-o" title="Link to this heading"></a></h4>
<p>| Pin name | Direction |                       Description                        |
| :——: | :——-: | :——————————————————: |
|   sclk   |   input   |                      SD Card Clock                       |
|   ncs    |   input   |                    chip select signal                    |
|   mosi   |   input   |  SD card input, host sends commands and data to SD card  |
|   miso   |  output   | SD card output to send data or response to host computer |</p>
</section>
</section>
<section id="id61">
<h3>5.5 Registers<a class="headerlink" href="#id61" title="Link to this heading"></a></h3>
<p>|   Name    | Offset | bit width |                         Description                          |
| :——-: | :—-: | :——-: | :———————————————————-: |
|    csd    |   \    |    128    | The CSD is card-specific data register that provides information. |
|    cid    |   \    |    128    | The CID (Card Identification) register contains the card identification information. The value of the CID register is vendor specific. |
|    ocr    |   \    |    32     | This register describes the operating voltage range and status bit in the power supply.This model is SDHC with a voltage range of 2.7-3.6V |
|    scr    |   \    |    64     | SCR (SD Card Configuration Register) provides information on the SD memory card’s special features. |
|    st     |  0x0   |     4     |               Record SD card state transitions               |
|    ist    |  0x0   |     3     |  Recording state transitions during SD card initialisation   |
| init_done |  0x0   |     1     |                Initialisation completion flag                |
|   token   |  0x0   |     8     |          Record the start token for receiving data           |
| multi_st  |  0x0   |     2     | State machine for continuous data writing, implementation of interrupt commands |</p>
<section id="two-dimensional-array">
<h4>two-dimensional array<a class="headerlink" href="#two-dimensional-array" title="Link to this heading"></a></h4>
<p>|   Name    | bit width |      bit depth       |                       Description                        |
| :——-: | :——-: | :——————: | :——————————————————: |
| flash_mem |     8     | 32*1024*1024*1024 | Simulates the data storage area of an SD card, size 32GB |</p>
</section>
</section>
<section id="id62">
<h3>5.6 Checklist<a class="headerlink" href="#id62" title="Link to this heading"></a></h3>
<section id="design">
<h4>Design<a class="headerlink" href="#design" title="Link to this heading"></a></h4>
<p>| Command   | Result |
| :———: | :——: |
| cmd0      | done   |
| cmd1      | waived |
| cmd6      | waived |
| cmd8      | done   |
| cmd9      | done   |
| cmd10     | done   |
| cmd12     | done   |
| cmd13     | waived |
| cmd16     | done   |
| cmd17     | done   |
| cmd18     | doen   |
| cmd24     | done   |
| cmd25     | done   |
| cmd27     | waived |
| cmd28     | waived |
| cmd29     | waived |
| cmd30     | waived |
| cmd32     | waived |
| cmd33     | waived |
| cmd38     | waived |
| cmd42     | waived |
| cmd55     | done   |
| cmd56     | waived |
| cmd58     | done   |
| cmd59     | waived |
| acmd13    | done   |
| acmd18    | waived |
| acmd22    | waived |
| acmd23    | waived |
| acmd25    | waived |
| acmd26    | waived |
| acmd38    | waived |
| acmd41    | done   |
| acmd42    | waived |
| acmd43-49 | waived |
| acmd51    | done   |</p>
</section>
<section id="verify">
<h4>Verify<a class="headerlink" href="#verify" title="Link to this heading"></a></h4>
<p>| Command   | Result    |
| :———: | :———: |
| cmd0      | done      |
| cmd1      | waived    |
| cmd6      | waived    |
| cmd8      | done      |
| cmd9      | not start |
| cmd10     | not start |
| cmd12     | done      |
| cmd13     | waived    |
| cmd16     | done      |
| cmd17     | done      |
| cmd18     | doen      |
| cmd24     | done      |
| cmd25     | done      |
| cmd27     | waived    |
| cmd28     | waived    |
| cmd29     | waived    |
| cmd30     | waived    |
| cmd32     | waived    |
| cmd33     | waived    |
| cmd38     | waived    |
| cmd42     | waived    |
| cmd55     | done      |
| cmd56     | waived    |
| cmd58     | done      |
| cmd59     | waived    |
| acmd13    | not start |
| acmd18    | waived    |
| acmd22    | waived    |
| acmd23    | waived    |
| acmd25    | waived    |
| acmd26    | waived    |
| acmd38    | waived    |
| acmd41    | done      |
| acmd42    | waived    |
| acmd43-49 | waived    |
| acmd51    | not start |</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="test1" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, writer38.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>